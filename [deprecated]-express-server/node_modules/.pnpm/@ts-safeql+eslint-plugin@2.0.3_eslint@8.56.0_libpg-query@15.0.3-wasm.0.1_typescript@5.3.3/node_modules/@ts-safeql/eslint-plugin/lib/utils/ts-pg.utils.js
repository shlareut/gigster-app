"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTemplateLiteralToQueryText = void 0;
const shared_1 = require("@ts-safeql/shared");
const typescript_1 = __importDefault(require("typescript"));
const fp_ts_1 = require("./fp-ts");
const ts_utils_1 = require("./ts.utils");
function mapTemplateLiteralToQueryText(quasi, parser, checker, options) {
    let $idx = 0;
    let $queryText = "";
    for (const $quasi of quasi.quasis) {
        $queryText += $quasi.value.raw;
        if ($quasi.tail) {
            break;
        }
        const expression = quasi.expressions[$idx];
        const pgType = (0, fp_ts_1.pipe)(mapExpressionToTsTypeString({ expression, parser, checker }), (params) => getPgTypeFromTsType(Object.assign(Object.assign({}, params), { checker, options })));
        if (fp_ts_1.E.isLeft(pgType)) {
            return fp_ts_1.E.left(shared_1.InvalidQueryError.of(pgType.left, expression));
        }
        const pgTypeValue = pgType.right;
        $queryText += pgTypeValue === null ? `$${++$idx}` : `$${++$idx}::${pgTypeValue}`;
    }
    return fp_ts_1.E.right($queryText);
}
exports.mapTemplateLiteralToQueryText = mapTemplateLiteralToQueryText;
function mapExpressionToTsTypeString(params) {
    const tsNode = params.parser.esTreeNodeToTSNodeMap.get(params.expression);
    const tsType = params.checker.getTypeAtLocation(tsNode);
    return {
        node: tsNode,
        type: tsType,
    };
}
const tsTypeToPgTypeMap = {
    number: "int",
    string: "text",
    boolean: "boolean",
    bigint: "bigint",
    any: "text",
    unknown: "text",
};
const tsKindToPgTypeMap = {
    [typescript_1.default.SyntaxKind.StringLiteral]: "text",
    [typescript_1.default.SyntaxKind.NumericLiteral]: "int",
    [typescript_1.default.SyntaxKind.TrueKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.FalseKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.BigIntLiteral]: "bigint",
};
const tsFlagToTsTypeStringMap = {
    [typescript_1.default.TypeFlags.String]: "string",
    [typescript_1.default.TypeFlags.Number]: "number",
    [typescript_1.default.TypeFlags.Boolean]: "boolean",
    [typescript_1.default.TypeFlags.BigInt]: "bigint",
    [typescript_1.default.TypeFlags.NumberLiteral]: "number",
    [typescript_1.default.TypeFlags.StringLiteral]: "string",
    [typescript_1.default.TypeFlags.BooleanLiteral]: "boolean",
    [typescript_1.default.TypeFlags.BigIntLiteral]: "bigint",
};
const tsFlagToPgTypeMap = {
    [typescript_1.default.TypeFlags.String]: "text",
    [typescript_1.default.TypeFlags.Number]: "int",
    [typescript_1.default.TypeFlags.Boolean]: "boolean",
    [typescript_1.default.TypeFlags.BigInt]: "bigint",
    [typescript_1.default.TypeFlags.NumberLiteral]: "int",
    [typescript_1.default.TypeFlags.StringLiteral]: "text",
    [typescript_1.default.TypeFlags.BooleanLiteral]: "boolean",
    [typescript_1.default.TypeFlags.BigIntLiteral]: "bigint",
};
function getPgTypeFromTsTypeUnion(params) {
    const types = params.types.filter((t) => t.flags !== typescript_1.default.TypeFlags.Null);
    const isUnionOfTheSameType = types.every((t) => t.flags === types[0].flags);
    const pgType = tsFlagToPgTypeMap[types[0].flags];
    if (!isUnionOfTheSameType || pgType === undefined) {
        return fp_ts_1.E.left(createMixedTypesInUnionErrorMessage(types.map((t) => t.flags)));
    }
    return fp_ts_1.E.right(pgType);
}
function getPgTypeFromTsType(params) {
    var _a;
    if (params.node.kind === typescript_1.default.SyntaxKind.ConditionalExpression) {
        const whenTrue = params.checker.getTypeAtLocation(params.node.whenTrue);
        const whenTrueType = tsFlagToPgTypeMap[whenTrue.flags];
        const whenFalse = params.checker.getTypeAtLocation(params.node.whenFalse);
        const whenFalseType = tsFlagToPgTypeMap[whenFalse.flags];
        if (whenTrueType === undefined || whenFalseType === undefined) {
            return fp_ts_1.E.left(`Unsupported conditional expression flags (true = ${whenTrue.flags}, false = ${whenFalse.flags})`);
        }
        if (whenTrueType !== whenFalseType) {
            return fp_ts_1.E.left(`Conditional expression must have the same type (true = ${whenTrueType}, false = ${whenFalseType})`);
        }
        return fp_ts_1.E.right(whenTrueType);
    }
    if (params.node.kind === typescript_1.default.SyntaxKind.Identifier) {
        const symbol = params.checker.getSymbolAtLocation(params.node);
        const type = params.checker.getTypeOfSymbolAtLocation(symbol, params.node);
        if (ts_utils_1.TSUtils.isTsUnionType(type)) {
            return getPgTypeFromTsTypeUnion({ types: type.types });
        }
        if (ts_utils_1.TSUtils.isTsArrayUnionType(params.checker, type)) {
            return (0, fp_ts_1.pipe)(fp_ts_1.E.Do, fp_ts_1.E.chain(() => getPgTypeFromTsTypeUnion({ types: type.resolvedTypeArguments[0].types })), fp_ts_1.E.map((pgType) => `${pgType}[]`));
        }
    }
    if (params.node.kind in tsKindToPgTypeMap) {
        return fp_ts_1.E.right(tsKindToPgTypeMap[params.node.kind]);
    }
    if (params.type.flags in tsFlagToPgTypeMap) {
        return fp_ts_1.E.right(tsFlagToPgTypeMap[params.type.flags]);
    }
    if (params.type.flags === typescript_1.default.TypeFlags.Null) {
        return fp_ts_1.E.right(null);
    }
    if (ts_utils_1.TSUtils.isTsUnionType(params.type)) {
        const type = params.type.types.find((t) => t.flags in tsFlagToPgTypeMap);
        if (type !== undefined) {
            return fp_ts_1.E.right(tsFlagToPgTypeMap[type.flags]);
        }
    }
    const typeStr = params.checker.typeToString(params.type);
    const singularType = typeStr.replace(/\[\]$/, "");
    const isArray = typeStr !== singularType;
    const isSignularTypeSupported = singularType in tsTypeToPgTypeMap;
    if (isSignularTypeSupported) {
        return isArray
            ? fp_ts_1.E.right(`${tsTypeToPgTypeMap[singularType]}[]`)
            : fp_ts_1.E.right(tsTypeToPgTypeMap[singularType]);
    }
    const typesWithOverrides = Object.assign(Object.assign({}, shared_1.defaultTypeMapping), (_a = params.options.overrides) === null || _a === void 0 ? void 0 : _a.types);
    const override = Object.entries(typesWithOverrides)
        .map(([key, value]) => ({ pgType: key, tsType: value }))
        .find((entry) => (0, shared_1.doesMatchPattern)({
        pattern: typeof entry.tsType === "string" ? entry.tsType : entry.tsType.parameter,
        text: singularType,
    }));
    if (override !== undefined) {
        return isArray ? fp_ts_1.E.right(`${override.pgType}[]`) : fp_ts_1.E.right(override.pgType);
    }
    return fp_ts_1.E.left((0, shared_1.normalizeIndent) `
    The type "${typeStr}" has no corresponding PostgreSQL type.
    Please add it manually using the "overrides.types" option:

    \`\`\`ts
    {
      "connections": {
        ...,
        "overrides": {
          "types": {
            "PG TYPE (e.g. 'date')": "${typeStr}"
          }
        }
      }
    }
    \`\`\`

    Read docs - https://safeql.dev/api/#connections-overrides-types-optional
  `);
}
function createMixedTypesInUnionErrorMessage(flags) {
    const flagsAsText = flags
        .map((flag) => { var _a; return (_a = tsFlagToTsTypeStringMap[flag]) !== null && _a !== void 0 ? _a : `unknown (${flag})`; })
        .join(", ");
    return `Union types must be of the same type (found ${flagsAsText})`;
}
//# sourceMappingURL=ts-pg.utils.js.map