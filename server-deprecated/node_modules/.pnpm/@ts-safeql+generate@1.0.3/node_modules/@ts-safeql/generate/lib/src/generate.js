"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGenerator = void 0;
const shared_1 = require("@ts-safeql/shared");
const fp_ts_1 = require("fp-ts");
const postgres_1 = require("postgres");
const get_relations_with_joins_1 = require("./utils/get-relations-with-joins");
const get_nonnullable_columns_1 = require("./utils/get-nonnullable-columns");
function createGenerator() {
    const cacheMap = new Map();
    const overrideMap = new Map();
    return {
        generate: (params) => generate(params, cacheMap, overrideMap),
        dropCacheKey: (cacheKey) => cacheMap.delete(cacheKey),
        clearCache: () => cacheMap.clear(),
    };
}
exports.createGenerator = createGenerator;
async function generate(params, cacheMap, overrideMap) {
    const { sql, query, cacheKey, cacheMetadata = true } = params;
    const { pgColsByTableOidCache, pgTypes, pgEnums } = await (0, shared_1.getOrSetFromMapWithEnabled)({
        shouldCache: cacheMetadata,
        map: cacheMap,
        key: cacheKey,
        value: () => getDatabaseMetadata(sql),
    });
    const overrides = await (0, shared_1.getOrSetFromMapWithEnabled)({
        shouldCache: cacheMetadata,
        map: overrideMap,
        key: JSON.stringify(params.overrides),
        value: () => { var _a, _b; return ({ types: new Map(Object.entries((_b = (_a = params.overrides) === null || _a === void 0 ? void 0 : _a.types) !== null && _b !== void 0 ? _b : {})) }); },
    });
    try {
        const result = await sql.unsafe(query, [], { prepare: true }).describe();
        if (result.columns === undefined || result.columns === null || result.columns.length === 0) {
            return fp_ts_1.either.right({ result: null, stmt: result, query: query });
        }
        const duplicateCols = result.columns.filter((col, index) => result.columns.find((c, i) => c.name === col.name && i != index));
        if (duplicateCols.length > 0) {
            const dupes = duplicateCols.map((col) => ({
                table: pgColsByTableOidCache.get(col.table).find((c) => c.colName === col.name).tableName,
                column: col.name,
            }));
            return fp_ts_1.either.left(shared_1.DuplicateColumnsError.of({
                queryText: query,
                columns: dupes.map((x) => `${x.table}.${x.column}`),
            }));
        }
        const relationsWithJoins = (0, get_relations_with_joins_1.flattenRelationsWithJoinsMap)((0, get_relations_with_joins_1.getRelationsWithJoins)(params.pgParsed));
        const nonNullableColumnsBasedOnAST = (0, get_nonnullable_columns_1.getNonNullableColumns)(params.pgParsed);
        const columns = result.columns.map((col) => {
            var _a;
            const introspected = (_a = pgColsByTableOidCache
                .get(col.table)) === null || _a === void 0 ? void 0 : _a.find((x) => x.colNum === col.number);
            return {
                described: col,
                introspected: introspected,
                isNonNullableBasedOnAST: nonNullableColumnsBasedOnAST.has(col.name),
            };
        });
        return fp_ts_1.either.right({
            result: mapColumnAnalysisResultsToTypeLiteral({
                columns,
                pgTypes,
                pgEnums,
                relationsWithJoins,
                overrides,
                fieldTransform: params.fieldTransform,
                nullAsUndefined: params.nullAsUndefined,
                nullAsOptional: params.nullAsOptional,
            }),
            stmt: result,
            query: query,
        });
    }
    catch (e) {
        if (e instanceof postgres_1.PostgresError) {
            return fp_ts_1.either.left(shared_1.PostgresError.of({
                queryText: query,
                message: e.message,
                line: e.line,
                position: e.position,
            }));
        }
        throw e;
    }
}
async function getDatabaseMetadata(sql) {
    const pgTypes = await getPgTypes(sql);
    const pgCols = await getPgCols(sql);
    const pgEnums = await getPgEnums(sql);
    const pgColsByTableOidCache = (0, shared_1.groupBy)(pgCols, "tableOid");
    return { pgTypes, pgCols, pgEnums, pgColsByTableOidCache };
}
function mapColumnAnalysisResultsToTypeLiteral(params) {
    const properties = params.columns.map((col) => {
        const propertySignature = mapColumnAnalysisResultToPropertySignature({
            col,
            pgTypes: params.pgTypes,
            pgEnums: params.pgEnums,
            relationsWithJoins: params.relationsWithJoins,
            overrides: params.overrides,
            fieldTransform: params.fieldTransform,
            nullAsUndefined: params.nullAsUndefined,
            nullAsOptional: params.nullAsOptional,
        });
        return propertySignature;
    });
    return properties;
}
function buildInterfacePropertyValue(params) {
    const nullType = params.nullAsUndefined ? "undefined" : "null";
    const isNullable = params.isNullable && ["any", "null"].includes(params.value) === false;
    if (!isNullable) {
        return [params.key, params.value];
    }
    return [params.nullAsOptional ? `${params.key}?` : params.key, `${params.value} | ${nullType}`];
}
function checkIsNullableDueToRelation(params) {
    const { col, relationsWithJoins } = params;
    const findByJoin = relationsWithJoins.find((x) => x.joinRelName === col.tableName);
    if (findByJoin !== undefined) {
        switch (findByJoin.joinType) {
            case shared_1.LibPgQueryAST.JoinType.JOIN_LEFT:
            case shared_1.LibPgQueryAST.JoinType.JOIN_FULL:
                return true;
            case shared_1.LibPgQueryAST.JoinType.JOIN_TYPE_UNDEFINED:
            case shared_1.LibPgQueryAST.JoinType.JOIN_INNER:
            case shared_1.LibPgQueryAST.JoinType.JOIN_RIGHT:
            case shared_1.LibPgQueryAST.JoinType.JOIN_SEMI:
            case shared_1.LibPgQueryAST.JoinType.JOIN_ANTI:
            case shared_1.LibPgQueryAST.JoinType.JOIN_UNIQUE_OUTER:
            case shared_1.LibPgQueryAST.JoinType.JOIN_UNIQUE_INNER:
            case shared_1.LibPgQueryAST.JoinType.UNRECOGNIZED:
                return false;
            default:
                (0, shared_1.assertNever)(findByJoin.joinType);
        }
    }
    const findByRel = relationsWithJoins.filter((x) => x.relName === col.tableName);
    for (const rel of findByRel) {
        switch (rel.joinType) {
            case shared_1.LibPgQueryAST.JoinType.JOIN_RIGHT:
            case shared_1.LibPgQueryAST.JoinType.JOIN_FULL:
                return true;
            case shared_1.LibPgQueryAST.JoinType.JOIN_TYPE_UNDEFINED:
            case shared_1.LibPgQueryAST.JoinType.JOIN_INNER:
            case shared_1.LibPgQueryAST.JoinType.JOIN_LEFT:
            case shared_1.LibPgQueryAST.JoinType.JOIN_SEMI:
            case shared_1.LibPgQueryAST.JoinType.JOIN_ANTI:
            case shared_1.LibPgQueryAST.JoinType.JOIN_UNIQUE_OUTER:
            case shared_1.LibPgQueryAST.JoinType.JOIN_UNIQUE_INNER:
            case shared_1.LibPgQueryAST.JoinType.UNRECOGNIZED:
                return false;
            default:
                (0, shared_1.assertNever)(rel.joinType);
        }
    }
    return false;
}
function mapColumnAnalysisResultToPropertySignature(params) {
    var _a, _b, _c, _d, _e, _f;
    const pgTypeOid = (_b = (_a = params.col.introspected) === null || _a === void 0 ? void 0 : _a.colBaseTypeOid) !== null && _b !== void 0 ? _b : params.col.described.type;
    const valueAsEnum = (_c = params.pgEnums
        .get(pgTypeOid)) === null || _c === void 0 ? void 0 : _c.values.map((x) => `'${x}'`).join(" | ");
    const valueAsType = getTsTypeFromPgTypeOid({
        pgTypeOid: pgTypeOid,
        pgTypes: params.pgTypes,
    });
    const valueAsOverride = (() => {
        var _a, _b, _c;
        const pgType = params.pgTypes.get((_b = (_a = params.col.introspected) === null || _a === void 0 ? void 0 : _a.colTypeOid) !== null && _b !== void 0 ? _b : params.col.described.type);
        if (((_c = params.overrides) === null || _c === void 0 ? void 0 : _c.types) === undefined || pgType === undefined) {
            return undefined;
        }
        const override = params.overrides.types.get(pgType.name);
        return (0, shared_1.fmap)(override, (x) => (typeof x === "string" ? x : x.return));
    })();
    const value = (_d = valueAsOverride !== null && valueAsOverride !== void 0 ? valueAsOverride : valueAsEnum) !== null && _d !== void 0 ? _d : valueAsType;
    const key = (_e = params.col.described.name) !== null && _e !== void 0 ? _e : (_f = params.col.introspected) === null || _f === void 0 ? void 0 : _f.colName;
    let isNonNullable = params.col.isNonNullableBasedOnAST;
    if (!isNonNullable && params.col.introspected !== undefined) {
        isNonNullable = params.col.introspected.colNotNull;
        if (checkIsNullableDueToRelation({
            col: params.col.introspected,
            relationsWithJoins: params.relationsWithJoins,
        })) {
            isNonNullable = false;
        }
    }
    return buildInterfacePropertyValue({
        key: (0, shared_1.toCase)(key, params.fieldTransform),
        value: value,
        isNullable: !isNonNullable,
        nullAsUndefined: params.nullAsUndefined,
        nullAsOptional: params.nullAsOptional,
    });
}
function getTsTypeFromPgTypeOid(params) {
    const pgType = params.pgTypes.get(params.pgTypeOid);
    if (pgType === undefined) {
        return "unknown";
    }
    return getTsTypeFromPgType({ pgTypeName: pgType.name });
}
function getTsTypeFromPgType(params) {
    var _a;
    const { isArray, pgType } = parsePgType(params.pgTypeName);
    const tsType = (_a = shared_1.defaultTypesMap.get(pgType)) !== null && _a !== void 0 ? _a : "any";
    return isArray ? `${tsType}[]` : tsType;
}
function isPgTypeArray(pgType) {
    return pgType.startsWith("_");
}
function parsePgType(pgType) {
    const isArray = isPgTypeArray(pgType);
    return {
        isArray: isArray,
        pgType: isArray ? pgType.slice(1) : pgType,
    };
}
async function getPgEnums(sql) {
    const rows = await sql `
    SELECT pg_type.oid, pg_type.typname, pg_enum.enumlabel
    FROM pg_type
    JOIN pg_enum ON pg_enum.enumtypid = pg_type.oid
    WHERE pg_type.typtype = 'e'
    ORDER BY pg_type.typname, pg_enum.enumsortorder
  `;
    const map = new Map();
    for (const row of rows) {
        const existing = map.get(row.oid);
        if (existing === undefined) {
            map.set(row.oid, {
                name: row.typname,
                values: [row.enumlabel],
            });
            continue;
        }
        existing.values.push(row.enumlabel);
    }
    return map;
}
async function getPgTypes(sql) {
    const rows = await sql `
        SELECT oid, typname as name FROM pg_type
    `;
    const map = new Map();
    for (const row of rows) {
        map.set(row.oid, row);
    }
    return map;
}
async function getPgCols(sql) {
    const rows = await sql `
      SELECT
          pg_class.oid AS "tableOid",
          pg_class.relname AS "tableName",
          pg_attribute.attname AS "colName",
          pg_type.oid AS "colTypeOid",
          CASE
              WHEN pg_type.typtype = 'd' THEN
                  (SELECT pt.oid FROM pg_type pt WHERE pt.oid = pg_type.typbasetype)
              ELSE
                  NULL
          END AS "colBaseTypeOid",
          pg_attribute.attnum AS "colNum",
          pg_attribute.atthasdef "colHasDef",
          pg_attribute.attnotnull "colNotNull"
      FROM
          pg_attribute,
          pg_class,
          pg_type
      WHERE TRUE
          AND pg_attribute.attrelid = pg_class.oid
          AND pg_attribute.atttypid = pg_type.oid
          AND pg_attribute.attnum >= 1
      ORDER BY
          pg_class.relname,
          pg_attribute.attname
  `;
    return rows;
}
//# sourceMappingURL=generate.js.map