"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RuleOptions = exports.Options = exports.UserConfigFile = exports.zConfig = exports.zConnectionMigration = void 0;
const shared_1 = require("@ts-safeql/shared");
const utils_1 = require("@typescript-eslint/utils");
const libpg_query_1 = __importDefault(require("libpg-query"));
const synckit_1 = require("synckit");
const ts_pattern_1 = require("ts-pattern");
const zod_1 = __importDefault(require("zod"));
const zod_to_json_schema_1 = __importDefault(require("zod-to-json-schema"));
const utils_2 = require("../utils");
const fp_ts_1 = require("../utils/fp-ts");
const get_type_properties_1 = require("../utils/get-type-properties");
const memoize_1 = require("../utils/memoize");
const node_utils_1 = require("../utils/node.utils");
const ts_pg_utils_1 = require("../utils/ts-pg.utils");
const check_sql_config_1 = require("./check-sql.config");
const check_sql_utils_1 = require("./check-sql.utils");
const messages = {
    typeInferenceFailed: "Type inference failed {{error}}",
    error: "{{error}}",
    invalidQuery: "Invalid Query: {{error}}",
    missingTypeAnnotations: "Query is missing type annotation\n\tFix with: {{fix}}",
    incorrectTypeAnnotations: `Query has incorrect type annotation.\n\tExpected: {{expected}}\n\tActual: {{actual}}`,
    invalidTypeAnnotations: `Query has invalid type annotation (SafeQL does not support it. If you think it should, please open an issue)`,
};
const zStringOrRegex = zod_1.default.union([zod_1.default.string(), zod_1.default.object({ regex: zod_1.default.string() })]);
const zBaseTarget = zod_1.default.object({
    /**
     * Transform the end result of the type.
     *
     * For example:
     *  - `"{type}[]"` will transform the type to an array
     *  - `["colname", "x_colname"]` will replace `colname` with `x_colname` in the type.
     *  - `["{type}[]", ["colname", x_colname"]]` will do both
     */
    transform: zod_1.default
        .union([zod_1.default.string(), zod_1.default.array(zod_1.default.union([zod_1.default.string(), zod_1.default.tuple([zod_1.default.string(), zod_1.default.string()])]))])
        .optional(),
    /**
     * Transform the (column) field key. Can be one of the following:
     * - `"snake"` - `userId` → `user_id`
     * - `"camel"` - `user_id` → `userId`
     * - `"pascal"` - `user_id` → `UserId`
     * - `"screaming snake"` - `user_id` → `USER_ID`
     */
    fieldTransform: zod_1.default.enum(["snake", "pascal", "camel", "screaming snake"]).optional(),
    /**
     * Whether or not to skip type annotation.
     */
    skipTypeAnnotations: zod_1.default.boolean().optional(),
});
/**
 * A target that acts as a wrapper for the query. For example:
 *
 * ```ts
 * const query = conn.query(sql`SELECT * FROM users`);
 *               ^^^^^^^^^^ wrapper
 * ```
 */
const zWrapperTarget = zod_1.default.object({ wrapper: zStringOrRegex }).merge(zBaseTarget);
/**
 * A target that is a tag expression. For example:
 *
 * ```ts
 * const query = sql`SELECT * FROM users`;
 *               ^^^ tag
 * ```
 */
const zTagTarget = zod_1.default.object({ tag: zStringOrRegex }).merge(zBaseTarget);
const zOverrideTypeResolver = zod_1.default.union([
    zod_1.default.string(),
    zod_1.default.object({ parameter: zStringOrRegex, return: zod_1.default.string() }),
]);
const zBaseSchema = zod_1.default.object({
    targets: zod_1.default.union([zWrapperTarget, zTagTarget]).array(),
    /**
     * Whether or not keep the connection alive. Change it only if you know what you're doing.
     */
    keepAlive: zod_1.default.boolean().optional(),
    /**
     * Override defaults
     */
    overrides: zod_1.default
        .object({
        types: zod_1.default.union([
            zod_1.default.record(zod_1.default.enum((0, shared_1.objectKeysNonEmpty)(shared_1.defaultTypeMapping)), zOverrideTypeResolver),
            zod_1.default.record(zod_1.default.string(), zOverrideTypeResolver),
        ]),
    })
        .partial()
        .optional(),
    /**
     * Use `undefined` instead of `null` when the value is nullable.
     */
    nullAsUndefined: zod_1.default.boolean().optional(),
    /**
     * Mark the property as optional when the value is nullable.
     */
    nullAsOptional: zod_1.default.boolean().optional(),
});
exports.zConnectionMigration = zod_1.default.object({
    /**
     * The path where the migration files are located.
     */
    migrationsDir: zod_1.default.string(),
    /**
     * THIS IS NOT THE PRODUCTION DATABASE.
     *
     * A connection url to the database.
     * This is required since in order to run the migrations, a connection to postgres is required.
     * Will be used only to create and drop the shadow database (see `databaseName`).
     */
    connectionUrl: zod_1.default.string().optional(),
    /**
     * The name of the shadow database that will be created from the migration files.
     */
    databaseName: zod_1.default.string().optional(),
    /**
     * Whether or not should refresh the shadow database when the migration files change.
     */
    watchMode: zod_1.default.boolean().optional(),
});
const zConnectionUrl = zod_1.default.object({
    /**
     * The connection url to the database
     */
    databaseUrl: zod_1.default.string(),
});
const zRuleOptionConnection = zod_1.default.union([
    zBaseSchema.merge(exports.zConnectionMigration),
    zBaseSchema.merge(zConnectionUrl),
]);
exports.zConfig = zod_1.default.object({
    connections: zod_1.default.union([zod_1.default.array(zRuleOptionConnection), zRuleOptionConnection]),
});
exports.UserConfigFile = zod_1.default.object({ useConfigFile: zod_1.default.boolean() });
exports.Options = zod_1.default.union([exports.zConfig, exports.UserConfigFile]);
exports.RuleOptions = zod_1.default.array(exports.Options).min(1).max(1);
const workerPath = require.resolve("./check-sql.worker");
const generateSync = (0, synckit_1.createSyncFn)(workerPath, {
    tsRunner: "esbuild-register",
    timeout: 1000 * 60 * 5,
});
function check(params) {
    const connections = Array.isArray(params.config.connections)
        ? params.config.connections
        : [params.config.connections];
    for (const connection of connections) {
        for (const target of connection.targets) {
            checkConnection(Object.assign(Object.assign({}, params), { connection, target }));
        }
    }
}
function isTagMemberValid(expr) {
    // For example sql``
    if (utils_2.ESTreeUtils.isIdentifier(expr.tag)) {
        return true;
    }
    // For example Provider.sql``
    if (utils_2.ESTreeUtils.isMemberExpression(expr.tag) && utils_2.ESTreeUtils.isIdentifier(expr.tag.property)) {
        return true;
    }
    return false;
}
function checkConnection(params) {
    if ("tag" in params.target) {
        return checkConnectionByTagExpression(Object.assign(Object.assign({}, params), { target: params.target }));
    }
    if ("wrapper" in params.target) {
        return checkConnectionByWrapperExpression(Object.assign(Object.assign({}, params), { target: params.target }));
    }
    return (0, ts_pattern_1.match)(params.target).exhaustive();
}
const pgParseQueryE = (query) => {
    return (0, fp_ts_1.pipe)(fp_ts_1.E.tryCatch(() => libpg_query_1.default.parseQuerySync(query), (error) => shared_1.PostgresError.to(query, error)));
};
const generateSyncE = (0, fp_ts_1.flow)(generateSync, fp_ts_1.E.chain(fp_ts_1.J.parse), fp_ts_1.E.chainW((parsed) => parsed), fp_ts_1.E.mapLeft((error) => error));
function reportCheck(params) {
    const { context, tag, connection, target, projectDir, typeParameter, baseNode } = params;
    return (0, fp_ts_1.pipe)(fp_ts_1.E.Do, fp_ts_1.E.bind("parser", () => fp_ts_1.E.of(utils_1.ESLintUtils.getParserServices(context))), fp_ts_1.E.bind("checker", ({ parser }) => fp_ts_1.E.of(parser.program.getTypeChecker())), fp_ts_1.E.bind("query", ({ parser, checker }) => (0, ts_pg_utils_1.mapTemplateLiteralToQueryText)(tag.quasi, parser, checker, params.connection)), fp_ts_1.E.bindW("pgParsed", ({ query }) => pgParseQueryE(query)), fp_ts_1.E.bindW("result", ({ query, pgParsed }) => generateSyncE({ query, pgParsed, connection, target, projectDir })), fp_ts_1.E.fold((error) => {
        return (0, ts_pattern_1.match)(error)
            .with({ _tag: "DuplicateColumnsError" }, (error) => {
            return (0, check_sql_utils_1.reportDuplicateColumns)({ context, error, tag });
        })
            .with({ _tag: "PostgresError" }, (error) => {
            return (0, check_sql_utils_1.reportPostgresError)({ context, error, tag });
        })
            .with({ _tag: "InvalidQueryError" }, (error) => {
            return (0, check_sql_utils_1.reportInvalidQueryError)({ context, error });
        })
            .with({ _tag: "InvalidMigrationError" }, { _tag: "InvalidMigrationsPathError" }, { _tag: "DatabaseInitializationError" }, { _tag: "InternalError" }, (error) => {
            return (0, check_sql_utils_1.reportBaseError)({ context, error, tag });
        })
            .exhaustive();
    }, ({ result, checker, parser }) => {
        var _a;
        const shouldSkipTypeAnnotations = target.skipTypeAnnotations === true;
        if (shouldSkipTypeAnnotations) {
            return;
        }
        const isMissingTypeAnnotations = typeParameter === undefined;
        const resultWithTransformed = (0, check_sql_utils_1.withTransformType)(result, target.transform);
        if (isMissingTypeAnnotations) {
            if (resultWithTransformed.resultAsString === null) {
                return;
            }
            return (0, check_sql_utils_1.reportMissingTypeAnnotations)({
                tag: tag,
                context: context,
                baseNode: baseNode,
                actual: resultWithTransformed.resultAsString,
            });
        }
        const reservedTypes = (0, memoize_1.memoize)({
            key: `reserved-types:${JSON.stringify((_a = connection.overrides) === null || _a === void 0 ? void 0 : _a.types)}`,
            value: () => {
                var _a, _b;
                const types = new Set();
                for (const value of Object.values((_b = (_a = connection.overrides) === null || _a === void 0 ? void 0 : _a.types) !== null && _b !== void 0 ? _b : {})) {
                    types.add(typeof value === "string" ? value : value.return);
                }
                return types;
            },
        });
        const typeAnnotationState = getTypeAnnotationState({
            result: resultWithTransformed,
            typeParameter: typeParameter,
            transform: target.transform,
            checker: checker,
            parser: parser,
            reservedTypes: reservedTypes,
        });
        if (typeAnnotationState === "INVALID") {
            return (0, check_sql_utils_1.reportInvalidTypeAnnotations)({
                context: context,
                typeParameter: typeParameter,
            });
        }
        if (!typeAnnotationState.isEqual) {
            return (0, check_sql_utils_1.reportIncorrectTypeAnnotations)({
                context,
                typeParameter: typeParameter,
                expected: (0, check_sql_utils_1.arrayEntriesToTsTypeString)(typeAnnotationState.expected),
                actual: resultWithTransformed.resultAsString,
            });
        }
    }));
}
function checkConnectionByTagExpression(params) {
    const { context, tag, projectDir, connection, target } = params;
    const tagAsText = context
        .getSourceCode()
        .getText(tag.tag)
        .replace(/^this\./, "");
    if ((0, shared_1.doesMatchPattern)({ pattern: target.tag, text: tagAsText })) {
        return reportCheck({
            context,
            tag,
            connection,
            target,
            projectDir,
            baseNode: tag.tag,
            typeParameter: tag.typeParameters,
        });
    }
}
function checkConnectionByWrapperExpression(params) {
    const { context, tag, projectDir, connection, target } = params;
    if (!isTagMemberValid(tag) ||
        !utils_2.ESTreeUtils.isCallExpression(tag.parent) ||
        !utils_2.ESTreeUtils.isMemberExpression(tag.parent.callee)) {
        return;
    }
    const calleeAsText = context
        .getSourceCode()
        .getText(tag.parent.callee)
        .replace(/^this\./, "");
    if ((0, shared_1.doesMatchPattern)({ pattern: target.wrapper, text: calleeAsText })) {
        return reportCheck({
            context,
            tag,
            connection,
            target,
            projectDir,
            baseNode: tag.parent.callee,
            typeParameter: tag.parent.typeParameters,
        });
    }
}
function getTypeAnnotationState(params) {
    const { result: { result: generated }, typeParameter, transform, parser, checker, reservedTypes, } = params;
    if (typeParameter.params.length !== 1) {
        return "INVALID";
    }
    const typeNode = typeParameter.params[0];
    const { properties, isArray } = (0, get_type_properties_1.getTypeProperties)({
        checker,
        parser,
        typeNode,
        reservedTypes,
    });
    const expected = [...new Map(properties).entries()];
    return getTypesEquality({ expected, generated, transform, isArray });
}
function getTypesEquality(params) {
    const { expected, generated, isArray, transform } = params;
    if (expected === null && generated === null) {
        return { isEqual: true, expected, generated };
    }
    if (expected === null || generated === null) {
        return { isEqual: false, expected, generated };
    }
    const omitRegex = /[\n ;'"]/g;
    const expectedSorted = [...expected].sort(([a], [b]) => a.localeCompare(b));
    const generatedSorted = [...generated].sort(([a], [b]) => a.localeCompare(b));
    const $toString = (x) => {
        return x.map(([key, value]) => [key, value.replace(omitRegex, "")]).join("");
    };
    const expectedString = $toString(expectedSorted) + (isArray ? "[]" : "");
    const generatedString = transform
        ? (0, check_sql_utils_1.transformTypes)($toString(generatedSorted), transform)
        : $toString(generatedSorted);
    return {
        isEqual: expectedString === generatedString,
        expected,
        generated,
    };
}
const createRule = (utils_1.ESLintUtils.RuleCreator(() => `https://github.com/ts-safeql/safeql`));
exports.default = createRule({
    name: "check-sql",
    meta: {
        fixable: "code",
        docs: {
            description: "Ensure that sql queries have type annotations",
            recommended: "error",
            suggestion: true,
            requiresTypeChecking: false,
        },
        messages: messages,
        type: "problem",
        schema: (0, zod_to_json_schema_1.default)(exports.RuleOptions, { target: "openApi3" }),
    },
    defaultOptions: [],
    create(context) {
        if (!(0, check_sql_utils_1.shouldLintFile)(context)) {
            return {};
        }
        const projectDir = (0, memoize_1.memoize)({
            key: context.getFilename(),
            value: () => (0, node_utils_1.locateNearestPackageJsonDir)(context.getFilename()),
        });
        const config = (0, memoize_1.memoize)({
            key: JSON.stringify({ key: "config", options: context.options, projectDir }),
            value: () => (0, check_sql_config_1.getConfigFromFileWithContext)({ context, projectDir }),
        });
        return {
            TaggedTemplateExpression(tag) {
                check({ context, tag, config, projectDir });
            },
        };
    },
});
//# sourceMappingURL=check-sql.rule.js.map