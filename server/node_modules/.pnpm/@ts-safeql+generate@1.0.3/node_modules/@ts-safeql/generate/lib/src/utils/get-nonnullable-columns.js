"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNonNullableColumns = void 0;
const shared_1 = require("@ts-safeql/shared");
// Function names that are always non-nullable.
const nonNullFunctions = new Set([
    "count",
    "now",
    "abs",
    "ceil",
    "floor",
    "round",
    "sqrt",
    "cbrt",
    "exp",
    "log",
    "log10",
    "sin",
    "cos",
    "tan",
    "asin",
    "acos",
    "atan",
    "radians",
    "degrees",
    "length",
    "trim",
    "lower",
    "upper",
    "ascii",
    "concat",
    "concat_ws",
    "lpad",
    "rpad",
    "initcap",
    "left",
    "right",
    "cdat",
    "chr",
    "strpos",
    "substr",
    "translate",
    "current_date",
    "current_time",
    "current_timestamp",
    "localtime",
    "localtimestamp",
    "uuid_generate_v1",
    "uuid_generate_v4",
    "pi",
    "random",
    "exists",
    "row_number",
    "current_schema",
    "current_schemas",
    "inet_server_addr",
    "inet_server_port",
    "isfinite",
    "isnan",
    "pg_backend_pid",
    "pg_blocking_pids",
    "pg_cancel_backend",
    "pg_is_in_recovery",
    "pg_postmaster_start_time",
    "pg_relation_size",
    "pg_total_relation_size",
    "timeofday",
]);
function concatStringNodes(nodes) {
    var _a;
    return ((_a = nodes === null || nodes === void 0 ? void 0 : nodes.map((x) => { var _a; return (_a = x.String) === null || _a === void 0 ? void 0 : _a.sval; }).filter(Boolean).join(".")) !== null && _a !== void 0 ? _a : "");
}
function isColumnNonNullable(val, root) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (val === undefined) {
        return false;
    }
    if (val.A_Const) {
        return val.A_Const.isnull !== true;
    }
    if (val.FuncCall) {
        const functionName = concatStringNodes(val.FuncCall.funcname);
        return nonNullFunctions.has(functionName.toLowerCase());
    }
    if ((_a = val.TypeCast) === null || _a === void 0 ? void 0 : _a.arg) {
        return isColumnNonNullable(val.TypeCast.arg, root);
    }
    if (val.SubLink) {
        switch (val.SubLink.subLinkType) {
            case shared_1.LibPgQueryAST.SubLinkType.EXISTS_SUBLINK:
                return true;
            case shared_1.LibPgQueryAST.SubLinkType.ARRAY_SUBLINK:
                return true; // while the array itself can be non-nullable, the elements can be nullable
            case shared_1.LibPgQueryAST.SubLinkType.ALL_SUBLINK:
            case shared_1.LibPgQueryAST.SubLinkType.ANY_SUBLINK:
            case shared_1.LibPgQueryAST.SubLinkType.ROWCOMPARE_SUBLINK:
            case shared_1.LibPgQueryAST.SubLinkType.EXPR_SUBLINK:
            case shared_1.LibPgQueryAST.SubLinkType.MULTIEXPR_SUBLINK:
            case shared_1.LibPgQueryAST.SubLinkType.CTE_SUBLINK:
                return isColumnNonNullable(val.SubLink.subselect, root);
            case shared_1.LibPgQueryAST.SubLinkType.SUB_LINK_TYPE_UNDEFINED:
            case shared_1.LibPgQueryAST.SubLinkType.UNRECOGNIZED:
                return false;
            default:
                (0, shared_1.assertNever)(val.SubLink.subLinkType);
        }
    }
    if (((_b = val.A_Expr) === null || _b === void 0 ? void 0 : _b.kind) === shared_1.LibPgQueryAST.AExprKind.AEXPR_OP) {
        return (isColumnNonNullable(val.A_Expr.lexpr, root) && isColumnNonNullable(val.A_Expr.rexpr, root));
    }
    if (val.CaseExpr) {
        for (const when of val.CaseExpr.args) {
            if (!isColumnNonNullable((_c = when.CaseWhen) === null || _c === void 0 ? void 0 : _c.expr, root) ||
                !isColumnNonNullable((_d = when.CaseWhen) === null || _d === void 0 ? void 0 : _d.result, root)) {
                return false;
            }
        }
        if (val.CaseExpr.defresult && !isColumnNonNullable(val.CaseExpr.defresult, root)) {
            return false;
        }
        return true;
    }
    if (val.ColumnRef) {
        const refColumnName = concatStringNodes(val.ColumnRef.fields);
        for (const stmt of root.stmts) {
            if ((_f = (_e = stmt === null || stmt === void 0 ? void 0 : stmt.stmt) === null || _e === void 0 ? void 0 : _e.SelectStmt) === null || _f === void 0 ? void 0 : _f.whereClause) {
                const whereClause = stmt.stmt.SelectStmt.whereClause;
                const whereClauseColumnName = concatStringNodes((_j = (_h = (_g = whereClause.NullTest) === null || _g === void 0 ? void 0 : _g.arg) === null || _h === void 0 ? void 0 : _h.ColumnRef) === null || _j === void 0 ? void 0 : _j.fields);
                if (((_k = whereClause.NullTest) === null || _k === void 0 ? void 0 : _k.nulltesttype) === shared_1.LibPgQueryAST.NullTestType.IS_NOT_NULL &&
                    whereClauseColumnName === refColumnName) {
                    return true;
                }
            }
        }
    }
    if (val.CoalesceExpr) {
        for (const arg of val.CoalesceExpr.args) {
            if (isColumnNonNullable(arg, root)) {
                return true;
            }
        }
    }
    if (val.A_ArrayExpr) {
        // TODO: should we check the array elements?
        return true;
    }
    if (val.SelectStmt) {
        // TODO: maybe we should check the sublink type?
        const nonNullableColumnsInSubStmt = getNonNullableColumnsInSelectStmt(val.SelectStmt, root);
        return Array.from(nonNullableColumnsInSubStmt.values()).some(Boolean);
    }
    return false;
}
function getNodeName(node) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((node === null || node === void 0 ? void 0 : node.ColumnRef) !== undefined) {
        return concatStringNodes(node.ColumnRef.fields);
    }
    if (((_a = node === null || node === void 0 ? void 0 : node.A_Const) === null || _a === void 0 ? void 0 : _a.boolval) !== undefined) {
        return "bool";
    }
    if ((node === null || node === void 0 ? void 0 : node.TypeCast) !== undefined) {
        const typeName = concatStringNodes((_b = node.TypeCast.typeName) === null || _b === void 0 ? void 0 : _b.names);
        if (typeName === "pg_catalog.interval") {
            return "interval";
        }
        if (node.TypeCast.arg) {
            return getNodeName(node.TypeCast.arg);
        }
        return typeName.replace(/^pg_catalog\./, "");
    }
    if (((_c = node === null || node === void 0 ? void 0 : node.FuncCall) === null || _c === void 0 ? void 0 : _c.funcname) !== undefined) {
        return concatStringNodes(node.FuncCall.funcname);
    }
    if (((_d = node === null || node === void 0 ? void 0 : node.SubLink) === null || _d === void 0 ? void 0 : _d.subLinkType) === shared_1.LibPgQueryAST.SubLinkType.EXISTS_SUBLINK) {
        return "exists";
    }
    if (((_e = node === null || node === void 0 ? void 0 : node.SubLink) === null || _e === void 0 ? void 0 : _e.subLinkType) === shared_1.LibPgQueryAST.SubLinkType.ARRAY_SUBLINK) {
        return "array";
    }
    if (((_h = (_g = (_f = node === null || node === void 0 ? void 0 : node.SubLink) === null || _f === void 0 ? void 0 : _f.subselect) === null || _g === void 0 ? void 0 : _g.SelectStmt) === null || _h === void 0 ? void 0 : _h.targetList) !== undefined) {
        const subSelectTargetList = node.SubLink.subselect.SelectStmt.targetList;
        if ((subSelectTargetList === null || subSelectTargetList === void 0 ? void 0 : subSelectTargetList[0].ResTarget) !== undefined) {
            return getTargetName(subSelectTargetList[0].ResTarget);
        }
    }
    if ((node === null || node === void 0 ? void 0 : node.A_ArrayExpr) !== undefined) {
        return "array";
    }
    if ((node === null || node === void 0 ? void 0 : node.CaseExpr) !== undefined) {
        return "case";
    }
    if ((node === null || node === void 0 ? void 0 : node.CoalesceExpr) !== undefined) {
        return "coalesce";
    }
    return "?column?";
}
function getTargetName(target) {
    var _a;
    return (_a = target.name) !== null && _a !== void 0 ? _a : getNodeName(target.val);
}
function getNonNullableColumnsInSelectStmt(stmt, root) {
    var _a, _b, _c, _d, _e, _f, _g;
    const nonNullableColumns = new Set();
    for (const target of stmt.targetList) {
        if (target.ResTarget && isColumnNonNullable(target.ResTarget.val, root)) {
            nonNullableColumns.add(getTargetName(target.ResTarget));
        }
    }
    if (stmt.whereClause) {
        if (((_a = stmt.whereClause.NullTest) === null || _a === void 0 ? void 0 : _a.nulltesttype) === shared_1.LibPgQueryAST.NullTestType.IS_NOT_NULL) {
            const whereClauseName = concatStringNodes((_c = (_b = stmt.whereClause.NullTest.arg) === null || _b === void 0 ? void 0 : _b.ColumnRef) === null || _c === void 0 ? void 0 : _c.fields);
            nonNullableColumns.add(whereClauseName);
        }
        if (((_d = stmt.whereClause.BoolExpr) === null || _d === void 0 ? void 0 : _d.boolop) === shared_1.LibPgQueryAST.BoolExprType.AND_EXPR) {
            for (const arg of stmt.whereClause.BoolExpr.args) {
                if (((_e = arg.NullTest) === null || _e === void 0 ? void 0 : _e.nulltesttype) === shared_1.LibPgQueryAST.NullTestType.IS_NOT_NULL &&
                    ((_g = (_f = arg.NullTest.arg) === null || _f === void 0 ? void 0 : _f.ColumnRef) === null || _g === void 0 ? void 0 : _g.fields)) {
                    nonNullableColumns.add(concatStringNodes(arg.NullTest.arg.ColumnRef.fields));
                }
            }
        }
    }
    return nonNullableColumns;
}
function getNonNullableColumns(root) {
    var _a;
    for (const stmt of root.stmts) {
        if ((_a = stmt.stmt) === null || _a === void 0 ? void 0 : _a.SelectStmt) {
            return getNonNullableColumnsInSelectStmt(stmt.stmt.SelectStmt, root);
        }
    }
    return new Set();
}
exports.getNonNullableColumns = getNonNullableColumns;
//# sourceMappingURL=get-nonnullable-columns.js.map