"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const shared_1 = require("@ts-safeql/shared");
const test_utils_1 = require("@ts-safeql/test-utils");
const assert_1 = __importDefault(require("assert"));
const TE = __importStar(require("fp-ts/TaskEither"));
const O = __importStar(require("fp-ts/Option"));
const function_1 = require("fp-ts/function");
const libpg_query_1 = require("libpg-query");
const mocha_1 = require("mocha");
const generate_1 = require("./generate");
function runMigrations(sql) {
    return sql.unsafe(`
    CREATE TYPE certification AS ENUM ('HHA', 'RN', 'LPN', 'CNA', 'PCA', 'OTHER');
    CREATE DOMAIN phone_number AS TEXT CHECK (VALUE ~ '^[0-9]{3}-[0-9]{3}-[0-9]{4}$');

    CREATE TABLE caregiver (
        id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
        first_name TEXT NOT NULL,
        last_name TEXT NOT NULL
    );

    CREATE TABLE caregiver_certification (
      caregiver_id INTEGER NOT NULL REFERENCES caregiver(id),
      certification certification NOT NULL
    );

    CREATE TABLE caregiver_phonenumber (
      caregiver_id INTEGER NOT NULL REFERENCES caregiver(id),
      phone_number phone_number NOT NULL
    );

    CREATE TABLE agency (
        id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
        name TEXT NOT NULL
    );

    CREATE TABLE caregiver_agency (
        id INTEGER PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
        caregiver_id INT NOT NULL REFERENCES caregiver(id),
        agency_id INT NOT NULL REFERENCES agency(id)
    );

    CREATE TABLE test_date_column (
        date_col DATE NOT NULL,
        date_array date[] NOT NULL,
        instant_arr timestamptz[] NOT NULL,
        time_arr time[] NOT NULL,
        timetz_arr timetz[] NOT NULL,
        local_date_time_arr timestamp[] NOT NULL,
        nullable_date_arr date[] NULL
    );
  `);
}
let sql;
let dropFn;
(0, mocha_1.before)(async () => {
    const testDatabase = await (0, test_utils_1.setupTestDatabase)({
        databaseName: (0, test_utils_1.generateTestDatabaseName)(),
        postgresUrl: "postgres://postgres:postgres@localhost:5432/postgres",
    });
    dropFn = testDatabase.drop;
    sql = testDatabase.sql;
    await runMigrations(sql);
});
after(async () => {
    await sql.end();
    await dropFn();
});
const { generate } = (0, generate_1.createGenerator)();
const generateTE = (0, function_1.flow)(generate, TE.tryCatchK(function_1.identity, shared_1.InternalError.to));
const parseQueryTE = (0, function_1.flow)(libpg_query_1.parseQuery, TE.tryCatchK(function_1.identity, shared_1.InternalError.to));
const testQuery = async (params) => {
    const { query } = params;
    const cacheKey = "test";
    return (0, function_1.pipe)(TE.Do, TE.bind("pgParsed", () => parseQueryTE(params.query)), TE.bind("result", ({ pgParsed }) => generateTE({ sql, pgParsed, query, cacheKey, fieldTransform: undefined })), TE.chainW(({ result }) => TE.fromEither(result)), TE.match((error) => (0, function_1.pipe)(params.expectedError, O.fromNullable, O.fold(() => assert_1.default.fail(error.message), (expectedError) => assert_1.default.strictEqual(error.message, expectedError))), ({ result }) => assert_1.default.deepEqual(result, params.expected)))();
};
(0, mocha_1.test)("(init generate cache)", async () => {
    await testQuery({
        query: `SELECT 1 as x`,
        expected: [["x", "number"]],
    });
});
(0, mocha_1.test)("select columns", async () => {
    await testQuery({
        query: `SELECT id, first_name, last_name from caregiver LIMIT 1`,
        expected: [
            ["id", "number"],
            ["first_name", "string"],
            ["last_name", "string"],
        ],
    });
});
(0, mocha_1.test)("select column as camelCase", async () => {
    await testQuery({
        query: `SELECT first_name as "firstName" from caregiver LIMIT 1`,
        expected: [["firstName", "string"]],
    });
});
(0, mocha_1.test)("select non-table column", async () => await testQuery({
    query: `SELECT 1 as count`,
    expected: [["count", "number"]],
}));
(0, mocha_1.test)("select with an inner join", async () => {
    await testQuery({
        query: `
        SELECT
            caregiver.id as caregiver_id,
            caregiver_agency.id as assoc_id
        FROM caregiver
            JOIN caregiver_agency ON caregiver.id = caregiver_agency.caregiver_id
    `,
        expected: [
            ["caregiver_id", "number"],
            ["assoc_id", "number"],
        ],
    });
});
(0, mocha_1.test)("select with left join should return all cols from left join as nullable", async () => {
    await testQuery({
        query: `
        SELECT
            caregiver.id as caregiver_id,
            caregiver_agency.id as assoc_id
        FROM caregiver
            LEFT JOIN caregiver_agency ON caregiver.id = caregiver_agency.caregiver_id
    `,
        expected: [
            ["caregiver_id", "number"],
            ["assoc_id", "number | null"],
        ],
    });
});
(0, mocha_1.test)("select with right join should return all cols from the other table as nullable", async () => {
    await testQuery({
        query: `
        SELECT
            caregiver.id as caregiver_id,
            caregiver_agency.id as assoc_id
        FROM caregiver
            RIGHT JOIN caregiver_agency ON caregiver.id = caregiver_agency.caregiver_id
    `,
        expected: [
            ["caregiver_id", "number | null"],
            ["assoc_id", "number"],
        ],
    });
});
(0, mocha_1.test)("select with full join should return all cols as nullable", async () => {
    await testQuery({
        query: `
        SELECT
            caregiver.id as caregiver_id,
            caregiver_agency.id as assoc_id
        FROM caregiver
            FULL JOIN caregiver_agency ON caregiver.id = caregiver_agency.caregiver_id
    `,
        expected: [
            ["caregiver_id", "number | null"],
            ["assoc_id", "number | null"],
        ],
    });
});
(0, mocha_1.test)("select with duplicate columns should throw duplicate columns error", async () => {
    await testQuery({
        query: `
        SELECT
          caregiver.id,
          caregiver_agency.id
        FROM caregiver
            JOIN caregiver_agency ON caregiver.id = caregiver_agency.caregiver_id
    `,
        expectedError: "Duplicate columns: caregiver.id, caregiver_agency.id",
    });
});
(0, mocha_1.test)("insert into table with returning", async () => {
    await testQuery({
        query: `INSERT INTO caregiver (first_name, last_name) VALUES (null, null) RETURNING id`,
        expected: [["id", "number"]],
    });
});
(0, mocha_1.test)("insert into table without returning", async () => {
    await testQuery({
        query: `INSERT INTO caregiver (first_name, last_name) VALUES (null, null)`,
        expected: null,
    });
});
(0, mocha_1.test)("select with incorrect operation", async () => {
    await testQuery({
        query: `SELECT id FROM caregiver WHERE first_name = 1`,
        expectedError: "operator does not exist: text = integer",
    });
});
(0, mocha_1.test)("select where int column = any(array)", async () => {
    await testQuery({
        query: `SELECT id FROM caregiver WHERE id = ANY($1::int[])`,
        expected: [["id", "number"]],
    });
});
(0, mocha_1.test)("select with syntax error", async () => {
    await testQuery({
        query: `SELECT id FROM caregiver WHERE`,
        expectedError: "Internal error: syntax error at end of input",
    });
});
(0, mocha_1.test)("select date columns", async () => {
    await testQuery({
        query: `SELECT * FROM test_date_column`,
        expected: [
            ["date_col", "Date"],
            ["date_array", "Date[]"],
            ["instant_arr", "Date[]"],
            ["time_arr", "string[]"],
            ["timetz_arr", "string[]"],
            ["local_date_time_arr", "Date[]"],
            ["nullable_date_arr", "Date[] | null"],
        ],
    });
});
(0, mocha_1.test)("select enum", async () => {
    await testQuery({
        query: `SELECT certification from caregiver_certification`,
        expected: [["certification", "'HHA' | 'RN' | 'LPN' | 'CNA' | 'PCA' | 'OTHER'"]],
    });
});
(0, mocha_1.test)("select domain type", async () => {
    await testQuery({
        query: `SELECT phone_number from caregiver_phonenumber`,
        expected: [["phone_number", "string"]],
    });
});
(0, mocha_1.test)("select from subselect with an alias", async () => {
    await testQuery({
        query: `
      SELECT subselect.id FROM (SELECT * FROM caregiver) AS subselect
    `,
        expected: [["id", "number"]],
    });
});
(0, mocha_1.test)("select from subselect with a join", async () => {
    await testQuery({
        query: `
    SELECT caregiver.first_name
    FROM
      (SELECT 1 as id) as subselect1
        LEFT JOIN caregiver ON subselect1.id = caregiver.id
    `,
        expected: [["first_name", "string | null"]],
    });
});
//# sourceMappingURL=generate.test.js.map