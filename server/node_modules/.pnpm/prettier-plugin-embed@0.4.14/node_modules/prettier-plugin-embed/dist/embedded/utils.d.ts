import type { Comment, Expression, TemplateLiteral } from "estree";
import type { AstPath, Doc } from "prettier";
import { builders } from "prettier/doc";
import type { LiteralUnion, OmitIndexSignature, UnionToIntersection } from "type-fest";
import type { InternalPrintFun } from "../types.js";
export declare function printTemplateExpression(path: AstPath<Expression & {
    comments?: Comment[];
}>, print: InternalPrintFun): builders.Doc[];
export declare function printTemplateExpressions(path: AstPath<TemplateLiteral>, print: InternalPrintFun): builders.Doc[][];
export declare function simpleRehydrateDoc(doc: Doc, placeholderRegex: RegExp, expressionDocs: Doc[], replaceLiteralNewlinesToHardlines?: boolean): builders.Doc[] | builders.DocCommand;
export declare function insertLanguage(languages: string[], language: string, firstLanguage: string): void;
export declare const randomUUID: () => string;
export declare function preparePlaceholder(leading?: string, trailing?: string): {
    createPlaceholder: (index: number) => string;
    placeholderRegex: RegExp;
};
export declare function escapeRegExp(text: string): string;
export declare function makeIdentifiersOptionName<T extends string>(language: T): `${T}Identifiers`;
export declare function makeCommentsOptionName<T extends string>(language: T): `${T}Comments`;
export declare function makeTagsOptionName<T extends string>(language: T): `${T}Tags`;
export declare function makePluginOptionName<T extends string>(language: T): `${T}Plugin`;
export declare function makeParserOptionName<T extends string>(language: T): `${T}Parser`;
export type AutocompleteStringList<T extends string> = LiteralUnion<T, string>[];
export type StringListToInterfaceKey<T extends readonly string[]> = {
    [key in T[number]]: undefined;
};
export type Satisfies<U, T extends U> = T;
export type NormalizeOptions<T> = OmitIndexSignature<{
    [k in keyof UnionToIntersection<T>]?: k extends keyof T ? T[k] : UnionToIntersection<T>[k];
}>;
