import { builders as T, utils as ii } from "prettier/doc";
import hi from "prettier/parser-babel";
import Ei from "prettier/parser-espree";
import bi from "prettier/parser-flow";
import fi from "prettier/parser-meriyah";
import yi from "prettier/parser-typescript";
import { printers as _i } from "prettier/plugins/estree.mjs";
import { resolveConfigFile as vi } from "prettier";
const { group: $i, indent: Di, softline: Pe, hardline: Ti, lineSuffixBoundary: Mi } = T, { mapDoc: Ai } = ii;
function Si(e, t) {
  const { node: n } = e;
  let r = t();
  return n?.comments?.length && (r = $i([Di([Pe, r]), Pe])), ["${", r, Mi, "}"];
}
function S(e, t) {
  return e.map(
    (n) => Si(n, t),
    "expressions"
  );
}
function A(e, t, n, r = !1) {
  return Ai(e, (a) => {
    if (typeof a != "string")
      return a;
    const s = [], l = a.split(t);
    for (let u = 0; u < l.length; u++) {
      let E = l[u];
      if (u % 2 === 0) {
        if (!E)
          continue;
        if (E = E.replaceAll(/([\\`]|\${)/g, "\\$1"), r)
          for (const d of E.split(/(\n)/))
            d === `
` ? s.push(Ti) : s.push(d);
        else
          s.push(E);
      } else {
        const d = Number(E);
        s.push(n[d]);
      }
    }
    return s;
  });
}
function Li(e, t, n) {
  if (t === n) {
    e.unshift(t);
    return;
  }
  let r = 0, i = e.length;
  for (; r < i; ) {
    const a = r + i >>> 1;
    if (e[a] === n) {
      e.push(t);
      return;
    }
    e[a] < t ? r = a + 1 : i = a;
  }
  e.splice(r, 0, t);
}
const me = (() => {
  const e = [...Array(26).keys()].map((t) => String.fromCharCode(t + 97)).concat([...Array(10).keys()].map((t) => `${t}`));
  return () => {
    let n = "";
    for (let r = 0; r < 16; ++r)
      n += e[parseInt((Math.random() * e.length).toFixed(0), 10) % e.length];
    return n;
  };
})();
function L(e = "p", t = "") {
  const n = me(), r = me(), i = Be(e), a = Be(t), s = (u) => `${e}${n}${u}${r}${t}`, l = new RegExp(
    `${i}${n}(\\d+)${r}${a}`,
    "ig"
  );
  return {
    createPlaceholder: s,
    placeholderRegex: l
  };
}
function Be(e) {
  return e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function $(e) {
  return `${e}Identifiers`;
}
function M(e) {
  return `${e}Comments`;
}
function D(e) {
  return `${e}Tags`;
}
function ki(e) {
  return `${e}Plugin`;
}
function N(e) {
  return `${e}Parser`;
}
const { line: qe, group: x, indent: je, softline: Ue } = T, Gi = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L("@p"), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedCssParser ?? "scss"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return x([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [x(o)] : je([x(o)]),
      p,
      "`"
    ]);
  const h = c.length ? qe : Ue, v = p.length ? qe : Ue;
  return x([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, x(o)] : je([h, x(o)]),
    v,
    "`"
  ]);
}, se = "embeddedCss", Ni = ["css"], Oi = ["css", "less", "scss"], xi = $(se), Re = M(se), Ce = D(se), Ii = N(se), Pi = {
  [xi]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ni] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded CSS language.",
    deprecated: `Please use \`${Re}\` or \`${Ce}\`.`
  },
  [Re]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded CSS language."
  },
  [Ce]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded CSS language."
  },
  [Ii]: {
    category: "Embed",
    type: "choice",
    default: "scss",
    description: "The parser used to parse the embedded CSS language.",
    choices: Oi.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Bi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Gi,
  language: se,
  options: Pi
}, Symbol.toStringTag, { value: "Module" })), { line: we, group: I, indent: Fe, softline: We } = T, qi = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedEsParser ?? "babel"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return I([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [I(o)] : Fe([I(o)]),
      p,
      "`"
    ]);
  const h = c.length ? we : We, v = p.length ? we : We;
  return I([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, I(o)] : Fe([h, I(o)]),
    v,
    "`"
  ]);
}, re = "embeddedEs", ji = [
  "js",
  "jsx",
  "es",
  "es6",
  "mjs",
  "cjs",
  "pac",
  "javascript"
], Ui = [
  "babel",
  "babel-flow",
  "acorn",
  "espree",
  "flow",
  "meriyah"
], Ri = $(re), ze = M(re), Ke = D(re), Ci = N(re), wi = {
  [Ri]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ji] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language.",
    deprecated: `Please use \`${ze}\` or \`${Ke}\`.`
  },
  [ze]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language."
  },
  [Ke]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded ECMAScript/JavaScript language."
  },
  [Ci]: {
    category: "Embed",
    type: "choice",
    default: "babel",
    description: "The parser used to parse the embedded ECMASCript/JavaScript language.",
    choices: Ui.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Fi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: qi,
  language: re,
  options: wi
}, Symbol.toStringTag, { value: "Module" })), { line: Je, group: P, indent: He, softline: Xe } = T, Wi = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "glsl-parser"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return P([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [P(o)] : He([P(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Je : Xe, v = p.length ? Je : Xe;
  return P([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, P(o)] : He([h, P(o)]),
    v,
    "`"
  ]);
}, Ee = "embeddedGlsl", zi = ["glsl", "shader"], Ki = $(Ee), Qe = M(Ee), Ye = D(Ee), Ji = {
  [Ki]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...zi] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin.",
    deprecated: `Please use \`${Qe}\` or \`${Ye}\`.`
  },
  [Qe]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin."
  },
  [Ye]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded GLSL language. This option requires the `prettier-plugin-glsl` plugin."
  }
}, Hi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Wi,
  language: Ee,
  options: Ji
}, Symbol.toStringTag, { value: "Module" })), { line: Ve, group: B, indent: Ze, softline: et } = T, Xi = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "graphql"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return B([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [B(o)] : Ze([B(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Ve : et, v = p.length ? Ve : et;
  return B([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, B(o)] : Ze([h, B(o)]),
    v,
    "`"
  ]);
}, be = "embeddedGraphql", Qi = ["graphql", "gql"], Yi = $(be), tt = M(be), nt = D(be), Vi = {
  [Yi]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Qi] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded GraphQL language.",
    deprecated: `Please use \`${tt}\` or \`${nt}\`.`
  },
  [tt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded GraphQL language."
  },
  [nt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded GraphQL language."
  }
}, Zi = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Xi,
  language: be,
  options: Vi
}, Symbol.toStringTag, { value: "Module" })), { line: it, group: q, indent: st, softline: rt } = T, { mapDoc: es } = ii, ts = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedHtmlParser ?? "html"
  }), o = es(_, (m) => {
    if (typeof m != "string")
      return m;
    const g = [], y = m.split(E);
    for (let k = 0; k < y.length; k++) {
      let G = y[k];
      if (k % 2 === 0) {
        if (!G)
          continue;
        G = G.replaceAll(/([\\`]|\${)/g, "\\$1"), s.__embeddedInHtml && (G = G.replaceAll(/<\/(?=script\b)/gi, "<\\/")), g.push(G);
      } else {
        const O = Number(G);
        g.push(b[O]);
      }
    }
    return g;
  });
  if (s.htmlWhitespaceSensitivity === "strict" || // TODO: is css mode should be included here?
  s.htmlWhitespaceSensitivity === "css" || s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return q([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [q(o)] : st([q(o)]),
      p,
      "`"
    ]);
  const h = c.length ? it : rt, v = p.length ? it : rt;
  return q([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, q(o)] : st([h, q(o)]),
    v,
    "`"
  ]);
}, oe = "embeddedHtml", ns = ["html", "xhtml"], is = ["html", "vue", "angular", "lwc"], ss = $(oe), ot = M(oe), at = D(oe), rs = N(oe), os = {
  [ss]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ns] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded HTML language.",
    deprecated: `Please use \`${ot}\` or \`${at}\`.`
  },
  [ot]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded HTML language."
  },
  [at]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded HTML language."
  },
  [rs]: {
    category: "Embed",
    type: "choice",
    default: "html",
    description: "The parser used to parse the embedded HTML language.",
    choices: is.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, as = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ts,
  language: oe,
  options: os
}, Symbol.toStringTag, { value: "Module" })), { line: dt, group: j, indent: lt, softline: ct } = T, ds = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "ini"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return j([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [j(o)] : lt([j(o)]),
      p,
      "`"
    ]);
  const h = c.length ? dt : ct, v = p.length ? dt : ct;
  return j([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, j(o)] : lt([h, j(o)]),
    v,
    "`"
  ]);
}, fe = "embeddedIni", ls = ["ini", "cfg", "pro"], cs = $(fe), ut = M(fe), pt = D(fe), us = {
  [cs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ls] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin.",
    deprecated: `Please use \`${ut}\` or \`${pt}\`.`
  },
  [ut]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin."
  },
  [pt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded INI language. This option requires the `prettier-plugin-ini` plugin."
  }
}, ps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ds,
  language: fe,
  options: us
}, Symbol.toStringTag, { value: "Module" })), { group: U, line: gt, softline: mt, indent: ht } = T, gs = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "java"
  }), o = A(
    _,
    E,
    b,
    !0
  );
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return U([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [U(o)] : ht([U(o)]),
      p,
      "`"
    ]);
  const h = c.length ? gt : mt, v = p.length ? gt : mt;
  return U([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, U(o)] : ht([h, U(o)]),
    v,
    "`"
  ]);
}, ye = "embeddedJava", ms = ["java"], hs = $(ye), Et = M(ye), bt = D(ye), Es = {
  [hs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ms] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin.",
    deprecated: `Please use \`${Et}\` or \`${bt}\`.`
  },
  [Et]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin."
  },
  [bt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Java language. This option requires the `prettier-plugin-java` plugin."
  }
}, bs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: gs,
  language: ye,
  options: Es
}, Symbol.toStringTag, { value: "Module" })), { line: ft, group: R, indent: yt, softline: _t } = T, fs = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = ys(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedJsonParser ?? "json"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return R([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [R(o)] : yt([R(o)]),
      p,
      "`"
    ]);
  const h = c.length ? ft : _t, v = p.length ? ft : _t;
  return R([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, R(o)] : yt([h, R(o)]),
    v,
    "`"
  ]);
};
function ys() {
  const e = me(), t = me(), n = (i) => `'0${e}${i}${t}'`, r = new RegExp(
    `["']?0${e}(\\d+)${t}['"]?`,
    "ig"
  );
  return {
    createPlaceholder: n,
    placeholderRegex: r
  };
}
const ae = "embeddedJson", _s = ["json", "jsonl"], vs = ["json", "json5", "jsonc", "json-stringify"], $s = $(ae), vt = M(ae), $t = D(ae), Ds = N(ae), Ts = {
  [$s]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [..._s] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded JSON language.",
    deprecated: `Please use \`${vt}\` or \`${$t}\`.`
  },
  [vt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded JSON language."
  },
  [$t]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded JSON language."
  },
  [Ds]: {
    category: "Embed",
    type: "choice",
    default: "json",
    description: "The parser used to parse the embedded JSON language.",
    choices: vs.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Ms = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: fs,
  language: ae,
  options: Ts
}, Symbol.toStringTag, { value: "Module" })), { line: Dt, group: C, indent: Tt, softline: Mt } = T, As = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L("$p"), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "JSONata"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return C([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [C(o)] : Tt([C(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Dt : Mt, v = p.length ? Dt : Mt;
  return C([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, C(o)] : Tt([h, C(o)]),
    v,
    "`"
  ]);
}, _e = "embeddedJsonata", Ss = ["jsonata"], Ls = $(_e), At = M(_e), St = D(_e), ks = {
  [Ls]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ss] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin.",
    deprecated: `Please use \`${At}\` or \`${St}\`.`
  },
  [At]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin."
  },
  [St]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded JSONata language. This option requires the `@stedi/prettier-plugin-jsonata` plugin."
  }
}, Gs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: As,
  language: _e,
  options: ks
}, Symbol.toStringTag, { value: "Module" })), { line: Lt, group: w, indent: kt, softline: Gt } = T, Ns = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "latex-parser"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return w([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [w(o)] : kt([w(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Lt : Gt, v = p.length ? Lt : Gt;
  return w([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, w(o)] : kt([h, w(o)]),
    v,
    "`"
  ]);
}, ve = "embeddedLatex", Os = [
  "latex",
  "tex",
  "aux",
  "cls",
  "bbl",
  "bib",
  "toc",
  "sty"
], xs = $(ve), Nt = M(ve), Ot = D(ve), Is = {
  [xs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Os] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin.",
    deprecated: `Please use \`${Nt}\` or \`${Ot}\`.`
  },
  [Nt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin."
  },
  [Ot]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded LaTeX language. This option requires the `prettier-plugin-latex` plugin."
  }
}, Ps = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Ns,
  language: ve,
  options: Is
}, Symbol.toStringTag, { value: "Module" })), { line: xt, group: F, indent: It, softline: Pt } = T, Bs = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedMarkdownParser ?? "markdown",
    __inJsTemplate: !0
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return F([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [F(o)] : It([F(o)]),
      p,
      "`"
    ]);
  const h = c.length ? xt : Pt, v = p.length ? xt : Pt;
  return F([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, F(o)] : It([h, F(o)]),
    v,
    "`"
  ]);
}, de = "embeddedMarkdown", qs = ["md", "markdown"], js = ["markdown", "mdx", "remark"], Us = $(de), Bt = M(de), qt = D(de), Rs = N(de), Cs = {
  [Us]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...qs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Markdown language.",
    deprecated: `Please use \`${Bt}\` or \`${qt}\`.`
  },
  [Bt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Markdown language."
  },
  [qt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Markdown language."
  },
  [Rs]: {
    category: "Embed",
    type: "choice",
    default: "markdown",
    description: "The parser used to parse the embedded Markdown language.",
    choices: js.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, ws = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Bs,
  language: de,
  options: Cs
}, Symbol.toStringTag, { value: "Module" })), { line: jt, group: W, indent: Ut, softline: Rt } = T, Fs = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "nginx"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return W([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [W(o)] : Ut([W(o)]),
      p,
      "`"
    ]);
  const h = c.length ? jt : Rt, v = p.length ? jt : Rt;
  return W([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, W(o)] : Ut([h, W(o)]),
    v,
    "`"
  ]);
}, $e = "embeddedNginx", Ws = ["nginx"], zs = $($e), Ct = M($e), wt = D($e), Ks = {
  [zs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ws] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin.",
    deprecated: `Please use \`${Ct}\` or \`${wt}\`.`
  },
  [Ct]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin."
  },
  [wt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded NGINX language. This option requires the `prettier-plugin-nginx` plugin."
  }
}, Js = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Fs,
  language: $e,
  options: Ks
}, Symbol.toStringTag, { value: "Module" })), le = "embeddedNoop", Hs = $(le), Ft = M(le), Wt = D(le), Xs = {
  [Hs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tag or comment identifiers that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted.",
    deprecated: `Please use \`${Ft}\` or \`${Wt}\`.`
  },
  [Ft]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted."
  },
  [Wt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that prevent their subsequent template literals from being identified as embedded languages and thus from being formatted."
  }
}, Qs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  language: le,
  options: Xs
}, Symbol.toStringTag, { value: "Module" })), { line: zt, group: z, indent: Kt, softline: Jt } = T, Ys = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "pegjs-parser"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return z([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [z(o)] : Kt([z(o)]),
      p,
      "`"
    ]);
  const h = c.length ? zt : Jt, v = p.length ? zt : Jt;
  return z([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, z(o)] : Kt([h, z(o)]),
    v,
    "`"
  ]);
}, De = "embeddedPegjs", Vs = ["pegjs", "peggy", "peg"], Zs = $(De), Ht = M(De), Xt = D(De), er = {
  [Zs]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Vs] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin.",
    deprecated: `Please use \`${Ht}\` or \`${Xt}\`.`
  },
  [Ht]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin."
  },
  [Xt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Pegjs language. This option requires the `prettier-plugin-pegjs` plugin."
  }
}, tr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Ys,
  language: De,
  options: er
}, Symbol.toStringTag, { value: "Module" })), { line: Qt, group: K, indent: Yt, softline: Vt } = T, nr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L("$p"), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "php"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return K([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [K(o)] : Yt([K(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Qt : Vt, v = p.length ? Qt : Vt;
  return K([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, K(o)] : Yt([h, K(o)]),
    v,
    "`"
  ]);
}, Te = "embeddedPhp", ir = ["php", "php5"], sr = $(Te), Zt = M(Te), en = D(Te), rr = {
  [sr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ir] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin.",
    deprecated: `Please use \`${Zt}\` or \`${en}\`.`
  },
  [Zt]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin."
  },
  [en]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded PHP language. This option requires the `@prettier/plugin-php` plugin."
  }
}, or = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: nr,
  language: Te,
  options: rr
}, Symbol.toStringTag, { value: "Module" })), { line: tn, group: J, indent: nn, softline: sn } = T, ar = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "prisma-parse"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return J([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [J(o)] : nn([J(o)]),
      p,
      "`"
    ]);
  const h = c.length ? tn : sn, v = p.length ? tn : sn;
  return J([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, J(o)] : nn([h, J(o)]),
    v,
    "`"
  ]);
}, Me = "embeddedPrisma", dr = ["prisma"], lr = $(Me), rn = M(Me), on = D(Me), cr = {
  [lr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...dr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin.",
    deprecated: `Please use \`${rn}\` or \`${on}\`.`
  },
  [rn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin."
  },
  [on]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Prisma language. This option requires the `prettier-plugin-prisma` plugin."
  }
}, ur = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ar,
  language: Me,
  options: cr
}, Symbol.toStringTag, { value: "Module" })), { line: an, group: H, indent: dn, softline: ln } = T, pr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "dot-properties"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return H([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [H(o)] : dn([H(o)]),
      p,
      "`"
    ]);
  const h = c.length ? an : ln, v = p.length ? an : ln;
  return H([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, H(o)] : dn([h, H(o)]),
    v,
    "`"
  ]);
}, Ae = "embeddedProperties", gr = ["properties"], mr = $(Ae), cn = M(Ae), un = D(Ae), hr = {
  [mr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...gr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin.",
    deprecated: `Please use \`${cn}\` or \`${un}\`.`
  },
  [cn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin."
  },
  [un]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Properties language. This option requires the `prettier-plugin-properties` plugin."
  }
}, Er = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: pr,
  language: Ae,
  options: hr
}, Symbol.toStringTag, { value: "Module" })), { group: X, line: pn, softline: gn, indent: mn } = T, br = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "pug"
  }), o = A(
    _,
    E,
    b,
    !0
  );
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return X([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [X(o)] : mn([X(o)]),
      p,
      "`"
    ]);
  const h = c.length ? pn : gn, v = p.length ? pn : gn;
  return X([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, X(o)] : mn([h, X(o)]),
    v,
    "`"
  ]);
}, Se = "embeddedPug", fr = ["pug", "jade"], yr = $(Se), hn = M(Se), En = D(Se), _r = {
  [yr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...fr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin.",
    deprecated: `Please use \`${hn}\` or \`${En}\`.`
  },
  [hn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin."
  },
  [En]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Pug language. This option requires the `@prettier/plugin-pug` plugin."
  }
}, vr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: br,
  language: Se,
  options: _r
}, Symbol.toStringTag, { value: "Module" })), { line: bn, group: Q, indent: fn, softline: yn } = T, $r = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedRubyParser ?? "ruby"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return Q([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [Q(o)] : fn([Q(o)]),
      p,
      "`"
    ]);
  const h = c.length ? bn : yn, v = p.length ? bn : yn;
  return Q([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, Q(o)] : fn([h, Q(o)]),
    v,
    "`"
  ]);
}, ce = "embeddedRuby", Dr = ["ruby"], Tr = ["ruby", "rbs", "haml"], Mr = $(ce), _n = M(ce), vn = D(ce), Ar = N(ce), Sr = {
  [Mr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Dr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin.",
    deprecated: `Please use \`${_n}\` or \`${vn}\`.`
  },
  [_n]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin."
  },
  [vn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin."
  },
  [Ar]: {
    category: "Embed",
    type: "choice",
    default: "ruby",
    description: "The parser used to parse the embedded Ruby language. This option requires the `@prettier/plugin-ruby` plugin.",
    choices: Tr.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Lr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: $r,
  language: ce,
  options: Sr
}, Symbol.toStringTag, { value: "Module" })), { group: Y, line: $n, softline: Dn, indent: Tn } = T, kr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "sh"
  }), o = A(
    _,
    E,
    b,
    !0
  );
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return Y([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [Y(o)] : Tn([Y(o)]),
      p,
      "`"
    ]);
  const h = c.length ? $n : Dn, v = p.length ? $n : Dn;
  return Y([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, Y(o)] : Tn([h, Y(o)]),
    v,
    "`"
  ]);
}, Le = "embeddedSh", Gr = ["sh"], Nr = $(Le), Mn = M(Le), An = D(Le), Or = {
  [Nr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Gr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin.",
    deprecated: `Please use \`${Mn}\` or \`${An}\`.`
  },
  [Mn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin."
  },
  [An]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded Shell language. This option requires the `prettier-plugin-sh` plugin."
  }
}, xr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: kr,
  language: Le,
  options: Or
}, Symbol.toStringTag, { value: "Module" }));
function Sn(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(e, i).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ln(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sn(Object(n), !0).forEach(function(r) {
      Ir(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sn(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Ir(e, t, n) {
  return t = Pr(t), t in e ? Object.defineProperty(e, t, { value: n, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = n, e;
}
function Pr(e) {
  var t = Br(e, "string");
  return typeof t == "symbol" ? t : String(t);
}
function Br(e, t) {
  if (typeof e != "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (typeof r != "object")
      return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
const qr = si({});
function si(e) {
  return t.withOptions = (n) => si(Ln(Ln({}, e), n)), t;
  function t(n, ...r) {
    const i = typeof n == "string" ? [n] : n.raw, {
      escapeSpecialCharacters: a = Array.isArray(n)
    } = e;
    let s = "";
    for (let E = 0; E < i.length; E++) {
      let d = i[E];
      a && (d = d.replace(/\\\n[ \t]*/g, "").replace(/\\`/g, "`").replace(/\\\$/g, "$").replace(/\\{/g, "{")), s += d, E < r.length && (s += r[E]);
    }
    const l = s.split(`
`);
    let u = null;
    for (const E of l) {
      const d = E.match(/^(\s+)\S+/);
      if (d) {
        const c = d[1].length;
        u ? u = Math.min(u, c) : u = c;
      }
    }
    if (u !== null) {
      const E = u;
      s = l.map((d) => d[0] === " " || d[0] === "	" ? d.slice(E) : d).join(`
`);
    }
    return s.trim().replace(/\\n/g, `
`);
  }
}
const { group: V, line: kn, softline: Gn, indent: Nn } = T, jr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, l = s.embeddedSqlPlugin ?? "prettier-plugin-sql", { node: u } = n, { createPlaceholder: E, placeholderRegex: d } = L(), c = u.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + E(g)
  ).join(""), p = c.match(/^\s+/)?.[0] ?? "", f = c.match(/\s+$/)?.[0] ?? "", b = c.slice(
    p.length,
    -f.length || void 0
  ), _ = S(n, t);
  let o;
  if (l === "prettier-plugin-sql-cst") {
    const m = await e(b, {
      ...s,
      parser: s.embeddedSqlParser ?? "sqlite"
    });
    o = A(m, d, _);
  } else {
    const m = await e(qr(b), {
      ...s,
      parser: "sql"
    });
    o = A(
      m,
      d,
      _,
      !0
    );
  }
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return V([
      "`",
      p,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [V(o)] : Nn([V(o)]),
      f,
      "`"
    ]);
  const h = p.length ? kn : Gn, v = f.length ? kn : Gn;
  return V([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, V(o)] : Nn([h, V(o)]),
    v,
    "`"
  ]);
}, ie = "embeddedSql", Ur = ["sql"], Rr = ["prettier-plugin-sql", "prettier-plugin-sql-cst"], Cr = [
  "sqlite",
  "bigquery",
  "mysql",
  "mariadb",
  "postgresql"
], wr = $(ie), On = M(ie), xn = D(ie), Fr = ki(ie), Wr = N(ie), zr = {
  [wr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Ur] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin.",
    deprecated: `Please use \`${On}\` or \`${xn}\`.`
  },
  [On]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin."
  },
  [xn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin."
  },
  [Fr]: {
    category: "Embed",
    type: "choice",
    default: "prettier-plugin-sql",
    description: "The plugin used to format the embedded SQL language. This option requires the `prettier-plugin-sql` plugin or the `prettier-plugin-sql-cst` plugin.",
    choices: Rr.map((e) => ({
      value: e,
      description: `Use the "${e}" plugin.`
    }))
  },
  [Wr]: {
    category: "Embed",
    type: "choice",
    default: "sqlite",
    description: "Specify the embedded SQL language parser. This option is only needed with the `prettier-plugin-sql-cst` plugin.",
    choices: Cr.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, Kr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: jr,
  language: ie,
  options: zr
}, Symbol.toStringTag, { value: "Module" })), { line: In, group: Z, indent: Pn, softline: Bn } = T, Jr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "toml"
  }), o = A(
    _,
    E,
    b,
    !0
  );
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return Z([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [Z(o)] : Pn([Z(o)]),
      p,
      "`"
    ]);
  const h = c.length ? In : Bn, v = p.length ? In : Bn;
  return Z([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, Z(o)] : Pn([h, Z(o)]),
    v,
    "`"
  ]);
}, ke = "embeddedToml", Hr = ["toml"], Xr = $(ke), qn = M(ke), jn = D(ke), Qr = {
  [Xr]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Hr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin.",
    deprecated: `Please use \`${qn}\` or \`${jn}\`.`
  },
  [qn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin."
  },
  [jn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded TOML language. This option requires the `prettier-plugin-toml` plugin."
  }
}, Yr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Jr,
  language: ke,
  options: Qr
}, Symbol.toStringTag, { value: "Module" })), { line: Un, group: ee, indent: Rn, softline: Cn } = T, Vr = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: s.embeddedTsParser ?? "typescript",
    // set filepath to undefined to enable jsx auto detection:
    // https://github.com/prettier/prettier/blob/427a84d24203e2d54160cde153a1e6a6390fe65a/src/language-js/parse/typescript.js#L49-L53
    filepath: void 0
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return ee([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [ee(o)] : Rn([ee(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Un : Cn, v = p.length ? Un : Cn;
  return ee([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, ee(o)] : Rn([h, ee(o)]),
    v,
    "`"
  ]);
}, ue = "embeddedTs", Zr = [
  "ts",
  "tsx",
  "cts",
  "mts",
  "typescript"
], eo = ["typescript", "babel-ts"], to = $(ue), wn = M(ue), Fn = D(ue), no = N(ue), io = {
  [to]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...Zr] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded TypeScript language.",
    deprecated: `Please use \`${wn}\` or \`${Fn}\`.`
  },
  [wn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded TypeScript language."
  },
  [Fn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded TypeScript language."
  },
  [no]: {
    category: "Embed",
    type: "choice",
    default: "typescript",
    description: "The parser used to parse the embedded TypeScript language.",
    choices: eo.map((e) => ({
      value: e,
      description: `Use the "${e}" parser.`
    }))
  }
}, so = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: Vr,
  language: ue,
  options: io
}, Symbol.toStringTag, { value: "Module" })), pe = "embeddedXml", { line: Wn, group: te, indent: zn, softline: Ne } = T, ro = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (g, y, { length: k }) => y === k - 1 ? g.value.cooked : g.value.cooked + u(y)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = [];
  let o = 0;
  for (; o !== void 0; ) {
    const g = f.slice(o);
    if (g.length === 0)
      break;
    o > 0 && s.xmlWhitespaceSensitivity !== "strict" && _.push(Ne), s.__embeddedXmlFragmentRecoverIndex?.splice(
      0,
      s.__embeddedXmlFragmentRecoverIndex.length
    );
    let y = await e(g, {
      ...s,
      parser: pe
    });
    const [k, G] = s.__embeddedXmlFragmentRecoverIndex ?? [];
    k === void 0 ? o = void 0 : G === void 0 ? o += k : (y = g.slice(k, G + 1), o += G + 1), _.push(y);
  }
  const h = A(_, E, b);
  if (s.xmlWhitespaceSensitivity === "strict" || s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return te([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [te(h)] : zn([te(h)]),
      p,
      "`"
    ]);
  const v = c.length ? Wn : Ne, m = p.length ? Wn : Ne;
  return te([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [v, te(h)] : zn([v, te(h)]),
    m,
    "`"
  ]);
}, oo = ["xml", "opml", "rss", "svg"], ao = $(pe), Kn = M(pe), Jn = D(pe), lo = {
  [ao]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...oo] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin.",
    deprecated: `Please use \`${Kn}\` or \`${Jn}\`.`
  },
  [Kn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin."
  },
  [Jn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded XML language. This option requires the `@prettier/plugin-xml` plugin."
  },
  /**
   * @internal
   */
  __embeddedXmlFragmentRecoverIndex: {
    category: "Embed",
    type: "int",
    array: !0,
    default: [{ value: [] }],
    description: "This option is read only and is used internally as a workaround to support xml fragments"
  }
};
function co(e) {
  const t = {
    loc: {
      start: {
        line: e.line,
        column: e.column
      },
      end: {
        line: e.line,
        column: e.column + e.length
      }
    }
  }, n = new SyntaxError(
    `${e.message} (${t.loc.start.line}:${t.loc.start.column})`,
    {
      cause: e
    }
  );
  return Object.assign(n, t), n;
}
function Hn(e) {
  const t = {
    loc: {
      start: {
        line: e.token.startLine ?? NaN,
        column: e.token.startColumn ?? NaN
      },
      end: {
        line: e.token.endLine ?? NaN,
        column: e.token.endColumn ?? NaN
      }
    }
  }, n = new SyntaxError(
    `${e.message} (${t.loc.start.line}:${t.loc.start.column})`,
    {
      cause: e
    }
  );
  return Object.assign(n, t), n;
}
const uo = {
  async parse(e, t) {
    const { parse: n } = await import("@xml-tools/parser"), { lexErrors: r, parseErrors: i, cst: a } = n(e);
    if (r.length > 0) {
      const s = r[0];
      throw co(s);
    }
    if (i.length > 0) {
      let s = !1;
      for (const l of i) {
        if (!["MismatchedTokenException", "NotAllInputParsedException"].includes(
          l.name
        ))
          throw Hn(l);
        if (l.message === "Expecting token of type --> OPEN <-- but found --> '' <--") {
          s = !0;
          continue;
        }
        if (/Expecting token of type --> EOF <-- but found --> '[\s\S]+' <--/.test(
          l.message
        ) || /Redundant input, expecting EOF but found: /.test(l.message)) {
          t.__embeddedXmlFragmentRecoverIndex?.splice(
            0,
            t.__embeddedXmlFragmentRecoverIndex.length,
            l.token.startOffset
          );
          break;
        }
        if (/Expecting token of type --> OPEN <-- but found --> '[\s\S]+' <--/.test(
          l.message
        )) {
          if (l.token.endOffset === void 0 || Number.isNaN(l.token.endOffset))
            break;
          t.__embeddedXmlFragmentRecoverIndex?.splice(
            0,
            t.__embeddedXmlFragmentRecoverIndex.length,
            l.token.startOffset,
            l.token.endOffset
          ), s = !0;
          break;
        }
        throw Hn(l);
      }
      s && ri(a);
    }
    return a;
  },
  astFormat: "xml",
  locStart(e) {
    return e.location.startOffset;
  },
  locEnd(e) {
    return e.location.endOffset ?? NaN;
  }
};
function ri(e) {
  const t = e.children;
  for (const n in t) {
    const r = t[n] ?? [];
    for (let i = r.length - 1; i >= 0; --i) {
      const a = r[i];
      if (po(a)) {
        if (Object.keys(a.children).length === 0) {
          r.splice(i, 1), r.length === 0 && delete t[n];
          continue;
        }
        ri(a);
      }
    }
  }
}
function po(e) {
  return "name" in e && "children" in e && "location" in e;
}
const go = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: ro,
  language: pe,
  options: lo,
  parser: uo
}, Symbol.toStringTag, { value: "Module" })), { line: Xn, group: ne, indent: Qn, softline: Yn } = T, mo = async (e, t, n, r, { commentOrTag: i, embeddedOverrideOptions: a }) => {
  const s = {
    ...r,
    ...a
  }, { node: l } = n, { createPlaceholder: u, placeholderRegex: E } = L(), d = l.quasis.map(
    (m, g, { length: y }) => g === y - 1 ? m.value.cooked : m.value.cooked + u(g)
  ).join(""), c = d.match(/^\s+/)?.[0] ?? "", p = d.match(/\s+$/)?.[0] ?? "", f = d.slice(
    c.length,
    -p.length || void 0
  ), b = S(n, t), _ = await e(f, {
    ...s,
    parser: "yaml"
  }), o = A(_, E, b);
  if (s.preserveEmbeddedExteriorWhitespaces?.includes(i))
    return ne([
      "`",
      c,
      s.noEmbeddedMultiLineIndentation?.includes(i) ? [ne(o)] : Qn([ne(o)]),
      p,
      "`"
    ]);
  const h = c.length ? Xn : Yn, v = p.length ? Xn : Yn;
  return ne([
    "`",
    s.noEmbeddedMultiLineIndentation?.includes(i) ? [h, ne(o)] : Qn([h, ne(o)]),
    v,
    "`"
  ]);
}, Ge = "embeddedYaml", ho = ["yaml", "yml"], Eo = $(Ge), Vn = M(Ge), Zn = D(Ge), bo = {
  [Eo]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [...ho] }],
    description: "Tag or comment identifiers that make their subsequent template literals be identified as embedded YAML language.",
    deprecated: `Please use \`${Vn}\` or \`${Zn}\`.`
  },
  [Vn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Block comments that make their subsequent template literals be identified as embedded YAML language."
  },
  [Zn]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Tags that make their subsequent template literals be identified as embedded YAML language."
  }
}, fo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  embedder: mo,
  language: Ge,
  options: bo
}, Symbol.toStringTag, { value: "Module" })), ge = [], oi = {}, ai = {}, di = {}, yo = /* @__PURE__ */ Object.assign({
  "./css/index.ts": Bi,
  "./es/index.ts": Fi,
  "./glsl/index.ts": Hi,
  "./graphql/index.ts": Zi,
  "./html/index.ts": as,
  "./ini/index.ts": ps,
  "./java/index.ts": bs,
  "./json/index.ts": Ms,
  "./jsonata/index.ts": Gs,
  "./latex/index.ts": Ps,
  "./markdown/index.ts": ws,
  "./nginx/index.ts": Js,
  "./noop/index.ts": Qs,
  "./pegjs/index.ts": tr,
  "./php/index.ts": or,
  "./prisma/index.ts": ur,
  "./properties/index.ts": Er,
  "./pug/index.ts": vr,
  "./ruby/index.ts": Lr,
  "./sh/index.ts": xr,
  "./sql/index.ts": Kr,
  "./toml/index.ts": Yr,
  "./ts/index.ts": so,
  "./xml/index.ts": go,
  "./yaml/index.ts": fo
});
for (const { language: e, parser: t, embedder: n, options: r } of Object.values(yo))
  Li(ge, e, le), t && (oi[e] = t), n && (ai[e] = n), Object.assign(di, r);
const _o = "noEmbeddedIdentificationByComment", vo = "noEmbeddedIdentificationByTag", $o = "preserveEmbeddedExteriorWhitespaces", Do = "noEmbeddedMultiLineIndentation", To = "embeddedOverrides", na = {
  ...di,
  /**
   * @deprecated Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore.
   */
  [_o]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off `` /* comment */ `...` `` comment-based embedded language identification for the specified identifiers.",
    deprecated: "Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore."
  },
  /**
   * @deprecated Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore.
   */
  [vo]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off `` tag`...` `` tag-based embedded language identification for the specified identifiers.",
    deprecated: "Please use `embedded<Language>Comments` or `embedded<Language>Tags` to configure each embedded language, and you won't need this option anymore."
  },
  [$o]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Preserves leading and trailing whitespaces in the formatting results for the specified comments or tags."
  },
  [Do]: {
    category: "Embed",
    type: "string",
    array: !0,
    default: [{ value: [] }],
    description: "Turns off auto indentation in the formatting results for the specified comments or tags when they are formatted to span multi lines."
  },
  [To]: {
    category: "Embed",
    type: "string",
    array: !1,
    default: void 0,
    description: "Option overrides for the specified comments or tags. It should either be a stringified JSON or an absolute filepath to the option overrides file."
  }
}, Mo = {
  // parsers from internal
  ...hi.parsers,
  ...Ei.parsers,
  ...bi.parsers,
  ...yi.parsers,
  ...fi.parsers,
  // parsers from this plugin
  ...oi
};
var Ao = {
  isEqual: !0,
  isMatchingKey: !0,
  isPromise: !0,
  maxSize: !0,
  onCacheAdd: !0,
  onCacheChange: !0,
  onCacheHit: !0,
  transformKey: !0
}, So = Array.prototype.slice;
function he(e) {
  var t = e.length;
  return t ? t === 1 ? [e[0]] : t === 2 ? [e[0], e[1]] : t === 3 ? [e[0], e[1], e[2]] : So.call(e, 0) : [];
}
function Lo(e) {
  var t = {};
  for (var n in e)
    Ao[n] || (t[n] = e[n]);
  return t;
}
function ko(e) {
  return typeof e == "function" && e.isMemoized;
}
function Go(e, t) {
  return e === t || e !== e && t !== t;
}
function ei(e, t) {
  var n = {};
  for (var r in e)
    n[r] = e[r];
  for (var r in t)
    n[r] = t[r];
  return n;
}
var No = (
  /** @class */
  function() {
    function e(t) {
      this.keys = [], this.values = [], this.options = t;
      var n = typeof t.isMatchingKey == "function";
      n ? this.getKeyIndex = this._getKeyIndexFromMatchingKey : t.maxSize > 1 ? this.getKeyIndex = this._getKeyIndexForMany : this.getKeyIndex = this._getKeyIndexForSingle, this.canTransformKey = typeof t.transformKey == "function", this.shouldCloneArguments = this.canTransformKey || n, this.shouldUpdateOnAdd = typeof t.onCacheAdd == "function", this.shouldUpdateOnChange = typeof t.onCacheChange == "function", this.shouldUpdateOnHit = typeof t.onCacheHit == "function";
    }
    return Object.defineProperty(e.prototype, "size", {
      /**
       * The number of cached [key,value] results.
       */
      get: function() {
        return this.keys.length;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "snapshot", {
      /**
       * A copy of the cache at a moment in time. This is useful
       * to compare changes over time, since the cache mutates
       * internally for performance reasons.
       */
      get: function() {
        return {
          keys: he(this.keys),
          size: this.size,
          values: he(this.values)
        };
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype._getKeyIndexFromMatchingKey = function(t) {
      var n = this.options, r = n.isMatchingKey, i = n.maxSize, a = this.keys, s = a.length;
      if (!s)
        return -1;
      if (r(a[0], t))
        return 0;
      if (i > 1) {
        for (var l = 1; l < s; l++)
          if (r(a[l], t))
            return l;
      }
      return -1;
    }, e.prototype._getKeyIndexForMany = function(t) {
      var n = this.options.isEqual, r = this.keys, i = r.length;
      if (!i)
        return -1;
      if (i === 1)
        return this._getKeyIndexForSingle(t);
      var a = t.length, s, l;
      if (a > 1) {
        for (var u = 0; u < i; u++)
          if (s = r[u], s.length === a) {
            for (l = 0; l < a && n(s[l], t[l]); l++)
              ;
            if (l === a)
              return u;
          }
      } else
        for (var u = 0; u < i; u++)
          if (s = r[u], s.length === a && n(s[0], t[0]))
            return u;
      return -1;
    }, e.prototype._getKeyIndexForSingle = function(t) {
      var n = this.keys;
      if (!n.length)
        return -1;
      var r = n[0], i = r.length;
      if (t.length !== i)
        return -1;
      var a = this.options.isEqual;
      if (i > 1) {
        for (var s = 0; s < i; s++)
          if (!a(r[s], t[s]))
            return -1;
        return 0;
      }
      return a(r[0], t[0]) ? 0 : -1;
    }, e.prototype.orderByLru = function(t, n, r) {
      for (var i = this.keys, a = this.values, s = i.length, l = r; l--; )
        i[l + 1] = i[l], a[l + 1] = a[l];
      i[0] = t, a[0] = n;
      var u = this.options.maxSize;
      s === u && r === s ? (i.pop(), a.pop()) : r >= u && (i.length = a.length = u);
    }, e.prototype.updateAsyncCache = function(t) {
      var n = this, r = this.options, i = r.onCacheChange, a = r.onCacheHit, s = this.keys[0], l = this.values[0];
      this.values[0] = l.then(function(u) {
        return n.shouldUpdateOnHit && a(n, n.options, t), n.shouldUpdateOnChange && i(n, n.options, t), u;
      }, function(u) {
        var E = n.getKeyIndex(s);
        throw E !== -1 && (n.keys.splice(E, 1), n.values.splice(E, 1)), u;
      });
    }, e;
  }()
);
function li(e, t) {
  if (t === void 0 && (t = {}), ko(e))
    return li(e.fn, ei(e.options, t));
  if (typeof e != "function")
    throw new TypeError("You must pass a function to `memoize`.");
  var n = t.isEqual, r = n === void 0 ? Go : n, i = t.isMatchingKey, a = t.isPromise, s = a === void 0 ? !1 : a, l = t.maxSize, u = l === void 0 ? 1 : l, E = t.onCacheAdd, d = t.onCacheChange, c = t.onCacheHit, p = t.transformKey, f = ei({
    isEqual: r,
    isMatchingKey: i,
    isPromise: s,
    maxSize: u,
    onCacheAdd: E,
    onCacheChange: d,
    onCacheHit: c,
    transformKey: p
  }, Lo(t)), b = new No(f), _ = b.keys, o = b.values, h = b.canTransformKey, v = b.shouldCloneArguments, m = b.shouldUpdateOnAdd, g = b.shouldUpdateOnChange, y = b.shouldUpdateOnHit, k = function() {
    var G = v ? he(arguments) : arguments;
    h && (G = p(G));
    var O = _.length ? b.getKeyIndex(G) : -1;
    if (O !== -1)
      y && c(b, f, k), O && (b.orderByLru(_[O], o[O], O), g && d(b, f, k));
    else {
      var gi = e.apply(this, arguments), mi = v ? G : he(arguments);
      b.orderByLru(mi, gi, _.length), s && b.updateAsyncCache(k), m && E(b, f, k), g && d(b, f, k);
    }
    return o[0];
  };
  return k.cache = b, k.fn = e, k.isMemoized = !0, k.options = f, k;
}
const Oo = /("(?:\\?[^])*?")|(\/\/.*)|(\/\*[^]*?\*\/)/g, xo = /("(?:\\?[^])*?")|(,\s*)(?=]|})/g, Ie = {
  parse: (e) => {
    e = String(e);
    try {
      return JSON.parse(e);
    } catch {
      return JSON.parse(e.replace(Oo, "$1").replace(xo, "$1"));
    }
  }
}, { label: Io } = T;
async function ti(e) {
  try {
    const { readFile: t } = await import("node:fs/promises"), n = await t(e, { encoding: "utf-8" });
    return Ie.parse(n);
  } catch {
  }
}
const Po = /* @__PURE__ */ new URL(
  `data:text/javascript,${encodeURIComponent('import{pathToFileURL as o}from"node:url";import{parentPort as t,workerData as a}from"node:worker_threads";const s=async({absolutePath:r})=>{try{const e=await import(o(r).href);t?.postMessage(e.embeddedOverrides??e.default??void 0)}catch{t?.postMessage(void 0)}};s(a);')}`
), Bo = /* @__PURE__ */ new URL(
  `data:text/javascript,${encodeURIComponent('import{register as a}from"node:module";import{pathToFileURL as s}from"node:url";import{parentPort as t,workerData as i}from"node:worker_threads";const d=async({absolutePath:r,importMetaUrl:o})=>{a("tsx/esm",{parentURL:o,data:!0});try{const e=await import(s(r).href);t?.postMessage(e.embeddedOverrides??e.default??void 0)}catch{t?.postMessage(void 0)}};d(i);')}`
);
async function qo(e) {
  const { Worker: t } = await import("node:worker_threads");
  return new Promise((n) => {
    const r = new t(Po, {
      workerData: {
        absolutePath: e
      }
    });
    r.once("message", (i) => {
      n(i);
    }), r.once("error", (i) => {
      console.error(i), n(void 0);
    });
  });
}
async function jo(e) {
  const { Worker: t } = await import("node:worker_threads");
  return new Promise((n) => {
    const r = new t(Bo, {
      workerData: {
        absolutePath: e,
        importMetaUrl: import.meta.url
      }
    });
    r.once("message", (i) => {
      n(i);
    }), r.once("error", (i) => {
      console.error(i), n(void 0);
    });
  });
}
const Uo = li(
  async (e, t) => {
    const { isAbsolute: n, dirname: r, resolve: i } = await import("node:path");
    if (n(e))
      return e;
    const a = await vi(t);
    let s;
    return typeof a != "string" ? s = process.env.PWD ?? process.cwd() : s = r(a), i(s, e);
  }
), Ro = async (e, t) => {
  let n;
  try {
    n = (await import("node:path")).extname(
      e
    );
  } catch {
    try {
      return Ie.parse(e);
    } catch {
      console.error("Failed to parse embeddedOverrides as a json object");
      return;
    }
  }
  const r = Uo(
    e,
    t
  );
  if (n === ".json" || n === ".jsonc") {
    const i = await r, a = await ti(i);
    if (a !== void 0)
      return a;
    console.error(`Failed to parse the json file: ${i}`);
    return;
  }
  if (n === ".mjs" || n === ".cjs" || n === ".js") {
    const i = await r, a = await qo(i);
    if (a !== void 0)
      return a;
    console.error(`Failed to parse the js module file: ${i}`);
    return;
  }
  if (n === ".mts" || n === ".cts" || n === ".ts") {
    const i = await r, a = await jo(i);
    if (a !== void 0)
      return a;
    console.error(`Failed to parse the ts module file: ${i}`);
    return;
  }
  if (n === "") {
    const i = await r, a = await ti(i);
    if (a !== void 0)
      return a;
  }
  try {
    return Ie.parse(e);
  } catch {
    console.error("Failed to parse embeddedOverrides as a json object");
  }
};
async function Co(e, {
  commentOrTag: t,
  kind: n,
  filepath: r
}) {
  if (e === void 0)
    return;
  const i = await Ro(
    e,
    r
  );
  if (i !== void 0)
    for (const {
      [`${n}s`]: a,
      identifiers: s,
      options: l
    } of i) {
      const u = a ?? [];
      if (u.length === 0 && s?.includes(t) || u.includes(t))
        return l;
    }
}
const wo = /* @__PURE__ */ (() => {
  const e = /* @__PURE__ */ new Set([
    "start",
    "end",
    "loc",
    "range",
    "filename",
    "typeAnnotation",
    "decorators"
  ]);
  return (t, n, r) => {
    let i;
    try {
      const s = r(`${n}\`\``);
      if (s instanceof Promise)
        throw new TypeError("Async parse function hasn't been supported yet.");
      i = s;
    } catch {
      return !1;
    }
    if (i.type === "File" && (i = i.program), !(i.type === "Program" && i.body[0]?.type === "ExpressionStatement"))
      return !1;
    const a = i.body[0]?.expression;
    return a?.type !== "TaggedTemplateExpression" ? !1 : !!ui(
      t,
      a.tag,
      e
    );
  };
})();
function Fo({
  node: e,
  parent: t
}) {
  const n = e.comments ?? t?.comments;
  if (!n)
    return;
  const r = n[n.length - 1];
  if (![
    "MultiLine",
    // meriyah
    "Block",
    // typescript, acorn, espree, flow
    "CommentBlock"
    // babel, babel-flow, babel-ts
  ].includes(r.type) || !r.leading)
    return;
  const i = r.value;
  if (i.length > 1 && i.startsWith(" ") && i.endsWith(" "))
    return i.slice(1, -1);
}
function Wo({
  parent: e
}) {
  if (e?.type === "TaggedTemplateExpression")
    return e.tag.type === "Identifier" ? e.tag.name : e.tag;
}
function zo(e, t) {
  const n = /* @__PURE__ */ (() => {
    let r;
    return () => (r === void 0 && (r = !(e.noEmbeddedIdentificationByComment?.includes(t) ?? !1)), r);
  })();
  return function* (r) {
    const i = e[M(r)] ?? [];
    i.length === 0 && n() ? yield* e[$(r)] ?? [] : yield* i;
  };
}
function ni(e, t) {
  if (typeof t == "string") {
    const n = /* @__PURE__ */ (() => {
      let r;
      return () => (r === void 0 && (r = !(e.noEmbeddedIdentificationByTag?.includes(t) ?? !1)), r);
    })();
    return function* (r) {
      const i = e[D(r)] ?? [];
      i.length === 0 && n() ? yield* e[$(r)] ?? [] : yield* i;
    };
  }
  return function* (n) {
    const r = e[D(n)] ?? [];
    if (r.length === 0) {
      const { noEmbeddedIdentificationByTag: i } = e;
      for (const a of e[$(n)] ?? [])
        i?.includes(a) || (yield a);
    } else
      yield* r;
  };
}
function Oe(e, t, n, r, i) {
  const a = ai[t];
  if (!a)
    return null;
  if (e.quasis.length === 1 && e.quasis[0]?.value.raw.trim() === "")
    return "``";
  const s = Co(
    i.embeddedOverrides,
    {
      commentOrTag: n,
      kind: r,
      filepath: i.filepath
    }
  );
  return async (...l) => {
    try {
      const u = await a(...l, {
        commentOrTag: n,
        kind: r,
        embeddedOverrideOptions: await s
      });
      return Io(
        {
          embed: !0,
          ...u.label
        },
        u
      );
    } catch (u) {
      throw console.error(u), u;
    }
  };
}
function ci(e, t, n) {
  return Object.is(e, t) ? !0 : e === null || t === null ? !1 : Array.isArray(e) ? Ko(e, t, n) : typeof e == "object" ? ui(e, t, n) : !1;
}
function Ko(e, t, n) {
  const r = e.length;
  if (r !== t.length)
    return !1;
  for (let i = 0; i < r; i++)
    if (!ci(e[i], t[i], n))
      return !1;
  return !0;
}
function ui(e, t, n) {
  for (const r of Object.keys(e))
    if (!n?.has(r) && !(Object.prototype.hasOwnProperty.call(t, r) && ci(e[r], t[r], n)))
      return !1;
  return !0;
}
const { estree: pi } = _i, { embed: xe } = pi, Jo = (e, t) => {
  const { node: n } = e;
  if (n.type !== "TemplateLiteral" || n.quasis.some(({ value: { cooked: a } }) => a === null))
    return null;
  const r = Fo(e);
  if (typeof r == "string") {
    const a = zo(
      t,
      r
    );
    for (const s of ge) {
      let l = !1;
      for (const u of a(
        s
      ))
        if (r === u) {
          l = !0;
          break;
        }
      if (l)
        return Oe(
          n,
          s,
          r,
          "comment",
          t
        );
    }
    return xe?.(e, t) ?? null;
  }
  const i = Wo(e);
  if (typeof i == "string") {
    const a = ni(t, i);
    for (const s of ge) {
      let l = !1;
      for (const u of a(s))
        if (i === u) {
          l = !0;
          break;
        }
      if (l)
        return Oe(n, s, i, "tag", t);
    }
    return xe?.(e, t) ?? null;
  }
  if (i !== void 0) {
    const a = (l) => Mo[t.parser].parse(
      l,
      t
    ), s = ni(t);
    for (const l of ge) {
      let u;
      for (const E of s(l))
        if (wo(i, E, a)) {
          u = E;
          break;
        }
      if (u !== void 0)
        return Oe(
          n,
          l,
          u,
          "tag",
          t
        );
    }
  }
  return xe?.(e, t) ?? null;
}, ia = {
  estree: {
    ...pi,
    embed: Jo
  }
};
export {
  na as options,
  Mo as parsers,
  ia as printers
};
