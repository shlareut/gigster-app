"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toInlineLiteralTypeString = exports.getTypeProperties = void 0;
const utils_1 = require("@typescript-eslint/utils");
const ts_utils_1 = require("./ts.utils");
function getTypeProperties(params) {
    const { typeNode, checker, parser, reservedTypes } = params;
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSArrayType) {
        const { properties } = getTypeProperties({
            typeNode: typeNode.elementType,
            parser,
            checker,
            reservedTypes,
        });
        return { properties, isArray: true };
    }
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSIntersectionType) {
        const properties = typeNode.types.flatMap((type) => getTypeProperties({ typeNode: type, parser, checker, reservedTypes }).properties);
        return { properties, isArray: false };
    }
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSTypeLiteral) {
        const properties = getTypePropertiesFromTypeLiteral({
            typeNode,
            parser,
            checker,
            reservedTypes,
        });
        return { properties, isArray: false };
    }
    if (typeNode.type === utils_1.TSESTree.AST_NODE_TYPES.TSTypeReference) {
        const type = checker.getTypeFromTypeNode(parser.esTreeNodeToTSNodeMap.get(typeNode));
        const properties = getTypePropertiesFromTypeReference({ type, typeNode, parser, checker });
        return { properties, isArray: false };
    }
    return { properties: [], isArray: false };
}
exports.getTypeProperties = getTypeProperties;
function getTypePropertiesFromTypeLiteral(params) {
    const { typeNode, checker, parser, reservedTypes } = params;
    const properties = [];
    for (const member of typeNode.members) {
        if (member.type !== utils_1.TSESTree.AST_NODE_TYPES.TSPropertySignature ||
            member.key.type !== utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
            continue;
        }
        const tsNode = parser.esTreeNodeToTSNodeMap.get(member);
        const tsNodeTypes = ts_utils_1.TSUtils.isTypeUnion(tsNode.type)
            ? tsNode.type.types
            : tsNode.type === undefined
                ? []
                : [tsNode.type];
        const actualType = tsNodeTypes
            .map((type) => {
            const originalTypeString = type.getText();
            return reservedTypes.has(originalTypeString)
                ? originalTypeString
                : checker.typeToString(checker.getTypeAtLocation(type));
        })
            .join(" | ");
        const key = member.optional ? `${member.key.name}?` : member.key.name;
        properties.push([key, actualType]);
    }
    return properties;
}
function getTypePropertiesFromTypeReference(params) {
    const { typeNode, type, parser, checker } = params;
    return type.getProperties().map((property) => {
        const type = checker.getTypeOfSymbolAtLocation(property, parser.esTreeNodeToTSNodeMap.get(typeNode));
        const typeName = checker.typeToString(type);
        return [property.escapedName.toString(), typeName];
    });
}
function toInlineLiteralTypeString(params) {
    const { properties, isArray } = params;
    const entries = [...properties.entries()].reduce((acc, [key, type]) => {
        acc.push(`${key}: ${type}`);
        return acc;
    }, []);
    if (entries.length === 0) {
        return isArray ? "{ }[]" : "{ }";
    }
    let typeString = `{ ${entries.join("; ")}; }`;
    if (isArray) {
        typeString = `${typeString}[]`;
    }
    return typeString;
}
exports.toInlineLiteralTypeString = toInlineLiteralTypeString;
//# sourceMappingURL=get-type-properties.js.map