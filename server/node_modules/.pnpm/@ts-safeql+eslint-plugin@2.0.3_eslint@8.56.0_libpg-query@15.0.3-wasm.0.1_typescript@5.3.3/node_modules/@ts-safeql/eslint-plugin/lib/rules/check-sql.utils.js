"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.arrayEntriesToTsTypeString = exports.runMigrations = exports.getConnectionStartegyByRuleOptionConnection = exports.getMigrationDatabaseMetadata = exports.isWatchMigrationsDirEnabled = exports.shouldLintFile = exports.getDatabaseName = exports.reportInvalidTypeAnnotations = exports.reportIncorrectTypeAnnotations = exports.reportMissingTypeAnnotations = exports.reportPostgresError = exports.reportDuplicateColumns = exports.reportBaseError = exports.reportInvalidQueryError = exports.withTransformType = exports.transformTypes = exports.DEFAULT_CONNECTION_URL = void 0;
const shared_1 = require("@ts-safeql/shared");
const crypto_1 = __importDefault(require("crypto"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const ts_pattern_1 = require("ts-pattern");
const utils_1 = require("../utils");
const fp_ts_1 = require("../utils/fp-ts");
const pg_utils_1 = require("../utils/pg.utils");
exports.DEFAULT_CONNECTION_URL = "postgres://postgres:postgres@localhost:5432/postgres";
function isReplacerFromTo(replacer) {
    return Array.isArray(replacer) && replacer.length === 2;
}
function transformType(typeString, typeReplacer) {
    return isReplacerFromTo(typeReplacer)
        ? typeString.replace(new RegExp(typeReplacer[0], "g"), typeReplacer[1])
        : typeReplacer.replace("{type}", typeString);
}
function transformTypes(typeString, transform) {
    if (transform === undefined || typeString === null) {
        return typeString;
    }
    if (typeof transform === "string") {
        return transformType(typeString, transform);
    }
    let transformed = typeString;
    for (const replacer of transform) {
        transformed = transformType(transformed, replacer);
    }
    return transformed;
}
exports.transformTypes = transformTypes;
/**
 * Takes a generated result and a transform type and returns a result with the
 * transformed type.
 *
 * @param transform could be either:
 *  - a string that has {type} in it,
 *  - an array of tuples that behave as [valueToBeReplaced, typeToReplaceWith]
 *  - an array that has a mix of the above (such as ["{type}[]", ["colname", "x_colname"]])
 */
function withTransformType(result, transform) {
    const resultAsString = arrayEntriesToTsTypeString(result.result);
    if (transform === undefined || result.result === null) {
        return Object.assign(Object.assign({}, result), { resultAsString });
    }
    const transformed = transformTypes(resultAsString, transform);
    return Object.assign(Object.assign({}, result), { resultAsString: transformed });
}
exports.withTransformType = withTransformType;
function reportInvalidQueryError(params) {
    const { context, error } = params;
    return context.report({
        messageId: "invalidQuery",
        node: error.node,
        data: { error: error.message },
    });
}
exports.reportInvalidQueryError = reportInvalidQueryError;
function reportBaseError(params) {
    const { context, tag, error } = params;
    return context.report({
        node: tag,
        messageId: "error",
        data: {
            error: error.message,
        },
    });
}
exports.reportBaseError = reportBaseError;
function reportDuplicateColumns(params) {
    const { tag, context, error } = params;
    return context.report({
        node: tag,
        messageId: "invalidQuery",
        loc: utils_1.ESTreeUtils.getSourceLocationFromStringPosition({
            loc: tag.quasi.loc,
            position: error.queryText.search(error.columns[0]) + 1,
            value: error.queryText,
        }),
        data: {
            error: error.message,
        },
    });
}
exports.reportDuplicateColumns = reportDuplicateColumns;
function reportPostgresError(params) {
    const { context, tag, error } = params;
    return context.report({
        node: tag,
        messageId: "invalidQuery",
        loc: utils_1.ESTreeUtils.getSourceLocationFromStringPosition({
            loc: tag.quasi.loc,
            position: parseInt(error.position, 10),
            value: error.queryText,
        }),
        data: {
            error: error.message,
        },
    });
}
exports.reportPostgresError = reportPostgresError;
function reportMissingTypeAnnotations(params) {
    const { context, tag, baseNode, actual } = params;
    return context.report({
        node: tag,
        messageId: "missingTypeAnnotations",
        loc: baseNode.loc,
        fix: (fixer) => fixer.insertTextAfterRange(baseNode.range, `<${actual}>`),
        data: {
            fix: actual,
        },
    });
}
exports.reportMissingTypeAnnotations = reportMissingTypeAnnotations;
function reportIncorrectTypeAnnotations(params) {
    var _a;
    const { context, typeParameter } = params;
    const newValue = params.actual === null ? "" : `<${params.actual}>`;
    return context.report({
        node: typeParameter.params[0],
        messageId: "incorrectTypeAnnotations",
        fix: (fixer) => fixer.replaceText(typeParameter, newValue),
        data: {
            expected: params.expected,
            actual: (_a = params.actual) !== null && _a !== void 0 ? _a : "No type annotation",
        },
    });
}
exports.reportIncorrectTypeAnnotations = reportIncorrectTypeAnnotations;
function reportInvalidTypeAnnotations(params) {
    const { context, typeParameter } = params;
    return context.report({
        node: typeParameter.params[0],
        messageId: "invalidTypeAnnotations",
    });
}
exports.reportInvalidTypeAnnotations = reportInvalidTypeAnnotations;
function getDatabaseName(params) {
    var _a;
    const { databaseName, projectDir, migrationsDir } = params;
    if (databaseName !== undefined) {
        return databaseName;
    }
    const projectDirName = (_a = projectDir.split("/").pop()) !== null && _a !== void 0 ? _a : "";
    const projectUnderscoreName = projectDirName.replace(/[^A-z0-9]/g, "_").toLowerCase();
    const hash = crypto_1.default.createHash("sha1").update(migrationsDir).digest("hex").substring(0, 8);
    return `safeql_${projectUnderscoreName}_${hash}`;
}
exports.getDatabaseName = getDatabaseName;
function shouldLintFile(params) {
    const fileName = params.getFilename();
    for (const extension of ["ts", "tsx", "mts", "mtsx"]) {
        if (fileName.endsWith(`.${extension}`)) {
            return true;
        }
    }
    return false;
}
exports.shouldLintFile = shouldLintFile;
function isMigrationConnection(connection) {
    return "migrationsDir" in connection;
}
function isWatchMigrationsDirEnabled(connection) {
    var _a;
    return isMigrationConnection(connection) && ((_a = connection.watchMode) !== null && _a !== void 0 ? _a : true) === true;
}
exports.isWatchMigrationsDirEnabled = isWatchMigrationsDirEnabled;
function getMigrationDatabaseMetadata(params) {
    const connectionOptions = Object.assign(Object.assign({}, (0, pg_utils_1.parseConnection)(params.connectionUrl)), { database: params.databaseName });
    const databaseUrl = (0, pg_utils_1.mapConnectionOptionsToString)(connectionOptions);
    return { databaseUrl, connectionOptions };
}
exports.getMigrationDatabaseMetadata = getMigrationDatabaseMetadata;
function getConnectionStartegyByRuleOptionConnection(params) {
    const { connection, projectDir } = params;
    if ("databaseUrl" in connection) {
        return Object.assign({ type: "databaseUrl" }, connection);
    }
    if ("migrationsDir" in connection) {
        return Object.assign({ type: "migrations", connectionUrl: exports.DEFAULT_CONNECTION_URL, databaseName: getDatabaseName({
                databaseName: connection.databaseName,
                migrationsDir: connection.migrationsDir,
                projectDir: projectDir,
            }), watchMode: isWatchMigrationsDirEnabled(connection) }, connection);
    }
    return (0, ts_pattern_1.match)(connection).exhaustive();
}
exports.getConnectionStartegyByRuleOptionConnection = getConnectionStartegyByRuleOptionConnection;
function runMigrations(params) {
    const runSingleMigrationFileWithSql = (filePath) => {
        return runSingleMigrationFile(params.sql, filePath);
    };
    return (0, fp_ts_1.pipe)(fp_ts_1.TE.Do, fp_ts_1.TE.chain(() => getMigrationFiles(params.migrationsPath)), fp_ts_1.TE.chainW((files) => fp_ts_1.TE.sequenceSeqArray(files.map(runSingleMigrationFileWithSql))));
}
exports.runMigrations = runMigrations;
function findDeepSqlFiles(migrationsPath) {
    const sqlFilePaths = [];
    function findDeepSqlFilesRecursively(dir) {
        const files = fs_1.default.readdirSync(dir);
        files.forEach((file) => {
            const filePath = path_1.default.join(dir, file);
            const isDirectory = fs_1.default.statSync(filePath).isDirectory();
            if (isDirectory) {
                findDeepSqlFilesRecursively(filePath);
            }
            else if (filePath.endsWith(".sql")) {
                sqlFilePaths.push(filePath);
            }
        });
    }
    findDeepSqlFilesRecursively(migrationsPath);
    return sqlFilePaths;
}
function getMigrationFiles(migrationsPath) {
    return (0, fp_ts_1.pipe)(fp_ts_1.E.tryCatch(() => findDeepSqlFiles(migrationsPath), fp_ts_1.E.toError), fp_ts_1.TE.fromEither, fp_ts_1.TE.mapLeft(shared_1.InvalidMigrationsPathError.fromErrorC(migrationsPath)));
}
function runSingleMigrationFile(sql, filePath) {
    return (0, fp_ts_1.pipe)(fp_ts_1.TE.tryCatch(() => fs_1.default.promises.readFile(filePath).then((x) => x.toString()), fp_ts_1.E.toError), fp_ts_1.TE.chain((content) => fp_ts_1.TE.tryCatch(() => sql.unsafe(content), fp_ts_1.E.toError)), fp_ts_1.TE.mapLeft(shared_1.InvalidMigrationError.fromErrorC(filePath)));
}
function arrayEntriesToTsTypeString(entries) {
    if (entries === null) {
        return null;
    }
    const properties = entries.map(([key, value]) => `${key}: ${value};`);
    if (properties.length === 0) {
        return "{ }";
    }
    return `{ ${properties.join(" ")} }`;
}
exports.arrayEntriesToTsTypeString = arrayEntriesToTsTypeString;
//# sourceMappingURL=check-sql.utils.js.map