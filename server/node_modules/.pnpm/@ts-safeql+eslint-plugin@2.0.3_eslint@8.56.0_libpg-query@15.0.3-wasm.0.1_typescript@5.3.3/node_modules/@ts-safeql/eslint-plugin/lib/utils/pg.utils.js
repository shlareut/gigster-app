"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dropDatabase = exports.createDatabase = exports.initDatabase = exports.parseConnection = exports.mapConnectionOptionsToString = void 0;
const shared_1 = require("@ts-safeql/shared");
const child_process_1 = require("child_process");
const pg_connection_string_1 = require("pg-connection-string");
const fp_ts_1 = require("./fp-ts");
function mapConnectionOptionsToString(connectionOptions) {
    return `postgres://${connectionOptions.user}:${connectionOptions.password}@${connectionOptions.host}:${connectionOptions.port}/${connectionOptions.database}`;
}
exports.mapConnectionOptionsToString = mapConnectionOptionsToString;
function parseConnection(databaseUrl) {
    const connection = (0, pg_connection_string_1.parse)(databaseUrl);
    if (connection.host === null) {
        throw new Error("Could not resolve database host");
    }
    if (!isDefined(connection.port)) {
        throw new Error("Could not resolve database port");
    }
    if (!isDefined(connection.user)) {
        throw new Error("Could not resolve database user");
    }
    if (!isDefined(connection.password)) {
        throw new Error("Could not resolve datbase password");
    }
    if (!isDefined(connection.database)) {
        throw new Error("Could not resolve database name");
    }
    return {
        host: connection.host,
        port: parseInt(connection.port, 10),
        user: connection.user,
        password: connection.password,
        database: connection.database,
    };
}
exports.parseConnection = parseConnection;
function initDatabase(connection) {
    return (0, fp_ts_1.pipe)(fp_ts_1.TE.Do, fp_ts_1.TE.chain(() => dropDatabase(connection)), fp_ts_1.TE.altW(() => fp_ts_1.TE.right(undefined)), fp_ts_1.TE.chain(() => createDatabase(connection)));
}
exports.initDatabase = initDatabase;
function createDatabase(connection) {
    const exec = (0, child_process_1.spawn)("createdb", [
        connection.database,
        "-h",
        connection.host,
        "-p",
        connection.port.toString(),
        "-U",
        connection.user,
    ], {
        env: Object.assign(Object.assign({}, process.env), { PGPASSWORD: connection.password }),
    });
    return execToTaskEither(exec, shared_1.DatabaseInitializationError.to);
}
exports.createDatabase = createDatabase;
function dropDatabase(connection) {
    const exec = (0, child_process_1.spawn)("dropdb", [
        connection.database,
        "--if-exists",
        "-h",
        connection.host,
        "-p",
        connection.port.toString(),
        "-U",
        connection.user,
        "--force",
    ], {
        env: Object.assign(Object.assign({}, process.env), { PGPASSWORD: connection.password }),
    });
    return execToTaskEither(exec, shared_1.DatabaseInitializationError.to);
}
exports.dropDatabase = dropDatabase;
function execToTaskEither(exec, mapLeft) {
    return fp_ts_1.TE.tryCatch(() => new Promise((resolve, reject) => {
        exec.stderr.on("data", (x) => reject(new Error(x)));
        exec.on("exit", (code) => (code === 0 ? resolve() : reject(new Error(code + ""))));
    }), mapLeft);
}
function isDefined(value) {
    return value !== null && value !== undefined;
}
//# sourceMappingURL=pg.utils.js.map