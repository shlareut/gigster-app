"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const generate_1 = require("@ts-safeql/generate");
const shared_1 = require("@ts-safeql/shared");
const path_1 = __importDefault(require("path"));
const synckit_1 = require("synckit");
const ts_pattern_1 = require("ts-pattern");
const connection_manager_1 = require("../utils/connection-manager");
const fp_ts_1 = require("../utils/fp-ts");
const pg_utils_1 = require("../utils/pg.utils");
const watch_manager_1 = require("../utils/watch-manager");
const check_sql_utils_1 = require("./check-sql.utils");
const generator = (0, generate_1.createGenerator)();
const connections = (0, connection_manager_1.createConnectionManager)();
const watchers = (0, watch_manager_1.createWatchManager)();
(0, synckit_1.runAsWorker)(async (params) => {
    if ((0, check_sql_utils_1.isWatchMigrationsDirEnabled)(params.connection)) {
        watchers.watchMigrationsDir({
            connection: params.connection,
            projectDir: params.projectDir,
            dropCacheKeyFn: generator.dropCacheKey,
            closeConnectionFn: connections.close,
        });
    }
    const result = await (0, fp_ts_1.pipe)(fp_ts_1.TE.Do, fp_ts_1.TE.chain(() => workerHandler(params)))();
    if (params.connection.keepAlive === false) {
        connections.close({ connection: params.connection, projectDir: params.projectDir });
    }
    return fp_ts_1.J.stringify(result);
});
function workerHandler(params) {
    const strategy = (0, check_sql_utils_1.getConnectionStartegyByRuleOptionConnection)(params);
    const connnectionPayload = (0, ts_pattern_1.match)(strategy)
        .with({ type: "databaseUrl" }, ({ databaseUrl }) => fp_ts_1.TE.right(connections.getOrCreate(databaseUrl)))
        .with({ type: "migrations" }, ({ migrationsDir, databaseName, connectionUrl }) => {
        const { connectionOptions, databaseUrl } = (0, check_sql_utils_1.getMigrationDatabaseMetadata)({
            connectionUrl,
            databaseName,
        });
        const { sql, isFirst } = connections.getOrCreate(databaseUrl);
        const connectionPayload = { sql, isFirst, databaseUrl };
        if (isFirst) {
            const migrationsPath = path_1.default.join(params.projectDir, migrationsDir);
            return (0, fp_ts_1.pipe)(fp_ts_1.TE.Do, fp_ts_1.TE.chainW(() => (0, pg_utils_1.initDatabase)(connectionOptions)), fp_ts_1.TE.chainW(() => (0, check_sql_utils_1.runMigrations)({ migrationsPath, sql })), fp_ts_1.TE.map(() => connectionPayload));
        }
        return fp_ts_1.TE.right(connectionPayload);
    })
        .exhaustive();
    const generateTask = (params) => {
        return fp_ts_1.TE.tryCatch(() => generator.generate(params), shared_1.InternalError.to);
    };
    return (0, fp_ts_1.pipe)(connnectionPayload, fp_ts_1.TE.chainW(({ sql, databaseUrl }) => {
        return generateTask({
            sql,
            query: params.query,
            cacheKey: databaseUrl,
            pgParsed: params.pgParsed,
            overrides: params.connection.overrides,
            fieldTransform: params.target.fieldTransform,
            nullAsUndefined: params.connection.nullAsUndefined,
            nullAsOptional: params.connection.nullAsOptional,
        });
    }), fp_ts_1.TE.chainW(fp_ts_1.TE.fromEither));
}
//# sourceMappingURL=check-sql.worker.js.map